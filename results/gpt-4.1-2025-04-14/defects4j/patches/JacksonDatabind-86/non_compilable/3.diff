diff --git a/tmp/948e120e-5311-463d-adf7-e8e712951c89_buggy.java b/tmp/1350d9e6-d2d8-4a8a-9cb4-20881a9cc090_fixed.java
index e69de29..ab58a4e 100644
--- a/tmp/948e120e-5311-463d-adf7-e8e712951c89_buggy.java
+++ b/tmp/1350d9e6-d2d8-4a8a-9cb4-20881a9cc090_fixed.java
@@ -0,0 +1,31 @@
+@Override
+public Map<String, AnnotatedMember> findBackReferences() {
+    // 24-Jun-2016, tatu: As per [databind#1647], when resolving recursive types,
+    //   we may end up with super-type only being resolved into `ResolvedRecursiveType`
+    //   placeholder. We must resolve it properly before using fields.
+    Map<String, AnnotatedMember> result = _backRefs;
+    if (result == null) {
+        result = new HashMap<>();
+        // Collect back references from superclass first
+        JavaType superType = getSuperClass();
+        if (superType != null) {
+            result.putAll(superType.findBackReferences());
+        }
+        // Then add back references from our own properties, overriding any from the superclass
+        for (BeanPropertyDefinition propDef : _properties) {
+            AnnotatedMember m = propDef.getMutator();
+            if (m != null) {
+                Object refType = _annotationIntrospector.findReferenceType(m);
+                if (refType != null && _annotationIntrospector.isBackReference(refType)) {
+                    String name = _annotationIntrospector.findReferenceName(m);
+                    if (name == null) {
+                        name = "defaultReference";
+                    }
+                    result.put(name, m);
+                }
+            }
+        }
+        _backRefs = result;
+    }
+    return result;
+}
\ No newline at end of file
