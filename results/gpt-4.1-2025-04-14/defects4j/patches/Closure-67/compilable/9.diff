diff --git a/tmp/21086e12-7fba-45b9-9424-dc87bdb50626_buggy.java b/tmp/8556823f-7a01-42c4-b46f-af937332862b_fixed.java
index 939f49b..6aa8684 100644
--- a/tmp/21086e12-7fba-45b9-9424-dc87bdb50626_buggy.java
+++ b/tmp/8556823f-7a01-42c4-b46f-af937332862b_fixed.java
@@ -1,21 +1,34 @@
 private boolean isPrototypePropertyAssign(Node assign) {
   Node n = assign.getFirstChild();
   if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
       && n.getType() == Token.GETPROP
       ) {
     // We want to exclude the assignment itself from the usage list
-        boolean isChainedProperty =
-            n.getFirstChild().getType() == Token.GETPROP;
-
-        if (isChainedProperty) {
-          Node child = n.getFirstChild().getFirstChild().getNext();
-
-          if (child.getType() == Token.STRING &&
-              child.getString().equals("prototype")) {
+    Node getprop = n;
+    // Check for chained property assignment, e.g. a.b = a.c = fn;
+    // Need to check both direct prototype assignment and aliases.
+    // Handle e.prototype.method = ...
+    Node tgt = getprop.getFirstChild();
+    if (tgt != null && tgt.getType() == Token.GETPROP) {
+      Node maybePrototype = tgt.getFirstChild().getNext();
+      if (maybePrototype != null &&
+          maybePrototype.getType() == Token.STRING &&
+          maybePrototype.getString().equals("prototype")) {
         return true;
       }
+    } else {
+      // Also handle: e.prototype['foo'] = ...
+      Node obj = getprop.getFirstChild();
+      Node prop = getprop.getLastChild();
+      if (obj != null && obj.getType() == Token.GETPROP) {
+        Node maybePrototype = obj.getFirstChild().getNext();
+        if (maybePrototype != null &&
+            maybePrototype.getType() == Token.STRING &&
+            maybePrototype.getString().equals("prototype")) {
+          return true;
+        }
+      }
     }
   }
-
   return false;
 }
\ No newline at end of file
