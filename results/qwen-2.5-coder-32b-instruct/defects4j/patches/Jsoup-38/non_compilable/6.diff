diff --git a/tmp/ae50d8df-9698-40b0-9b86-95693f013134_buggy.java b/tmp/0a060cc6-a8da-4924-b014-1a1001b3ad5c_fixed.java
index dbfba19..be4643c 100644
--- a/tmp/ae50d8df-9698-40b0-9b86-95693f013134_buggy.java
+++ b/tmp/0a060cc6-a8da-4924-b014-1a1001b3ad5c_fixed.java
@@ -1,507 +1,693 @@
 boolean process(Token t, HtmlTreeBuilder tb) {
     switch (t.type) {
         case Character: {
             Token.Character c = t.asCharacter();
             if (c.getData().equals(nullString)) {
                 // todo confirm that check
                 tb.error(this);
                 return false;
             } else if (isWhitespace(c)) {
                 tb.reconstructFormattingElements();
                 tb.insert(c);
             } else {
                 tb.reconstructFormattingElements();
                 tb.insert(c);
                 tb.framesetOk(false);
             }
             break;
         }
         case Comment: {
             tb.insert(t.asComment());
             break;
         }
         case Doctype: {
             tb.error(this);
             return false;
         }
         case StartTag:
             Token.StartTag startTag = t.asStartTag();
             String name = startTag.name();
             if (name.equals("html")) {
                 tb.error(this);
                 // merge attributes onto real html
                 Element html = tb.getStack().getFirst();
                 for (Attribute attribute : startTag.getAttributes()) {
                     if (!html.hasAttr(attribute.getKey()))
                         html.attributes().put(attribute);
                 }
             } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {
                 return tb.process(t, InHead);
             } else if (name.equals("body")) {
                 tb.error(this);
                 LinkedList<Element> stack = tb.getStack();
                 if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
                     // only in fragment case
                     return false; // ignore
                 } else {
                     tb.framesetOk(false);
                     Element body = stack.get(1);
                     for (Attribute attribute : startTag.getAttributes()) {
                         if (!body.hasAttr(attribute.getKey()))
                             body.attributes().put(attribute);
                     }
                 }
             } else if (name.equals("frameset")) {
                 tb.error(this);
                 LinkedList<Element> stack = tb.getStack();
                 if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
                     // only in fragment case
                     return false; // ignore
                 } else if (!tb.framesetOk()) {
                     return false; // ignore frameset
                 } else {
                     Element second = stack.get(1);
                     if (second.parent() != null)
                         second.remove();
                     // pop up to html element
                     while (stack.size() > 1)
                         stack.removeLast();
                     tb.insert(startTag);
                     tb.transition(InFrameset);
                 }
             } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insert(startTag);
             } else if (StringUtil.in(name, Constants.Headings)) {
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {
                     tb.error(this);
                     tb.pop();
                 }
                 tb.insert(startTag);
             } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insert(startTag);
                 // todo: ignore LF if next token
                 tb.framesetOk(false);
             } else if (name.equals("form")) {
                 if (tb.getFormElement() != null) {
                     tb.error(this);
                     return false;
                 }
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insertForm(startTag, true);
             } else if (name.equals("li")) {
                 tb.framesetOk(false);
                 LinkedList<Element> stack = tb.getStack();
                 for (int i = stack.size() - 1; i > 0; i--) {
                     Element el = stack.get(i);
                     if (el.nodeName().equals("li")) {
                         tb.process(new Token.EndTag("li"));
                         break;
                     }
                     if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))
                         break;
                 }
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insert(startTag);
             } else if (StringUtil.in(name, Constants.DdDt)) {
                 tb.framesetOk(false);
                 LinkedList<Element> stack = tb.getStack();
                 for (int i = stack.size() - 1; i > 0; i--) {
                     Element el = stack.get(i);
                     if (StringUtil.in(el.nodeName(), Constants.DdDt)) {
                         tb.process(new Token.EndTag(el.nodeName()));
                         break;
                     }
                     if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))
                         break;
                 }
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insert(startTag);
             } else if (name.equals("plaintext")) {
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insert(startTag);
                 tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
             } else if (name.equals("button")) {
                 if (tb.inButtonScope("button")) {
                     // close and reprocess
                     tb.error(this);
                     tb.process(new Token.EndTag("button"));
                     tb.process(startTag);
                 } else {
                     tb.reconstructFormattingElements();
                     tb.insert(startTag);
                     tb.framesetOk(false);
                 }
             } else if (name.equals("a")) {
                 if (tb.getActiveFormattingElement("a") != null) {
                     tb.error(this);
                     tb.process(new Token.EndTag("a"));
 
                     // still on stack?
                     Element remainingA = tb.getFromStack("a");
                     if (remainingA != null) {
                         tb.removeFromActiveFormattingElements(remainingA);
                         tb.removeFromStack(remainingA);
                     }
                 }
                 tb.reconstructFormattingElements();
                 Element a = tb.insert(startTag);
                 tb.pushActiveFormattingElements(a);
             } else if (StringUtil.in(name, Constants.Formatters)) {
                 tb.reconstructFormattingElements();
                 Element el = tb.insert(startTag);
                 tb.pushActiveFormattingElements(el);
             } else if (name.equals("nobr")) {
                 tb.reconstructFormattingElements();
                 if (tb.inScope("nobr")) {
                     tb.error(this);
                     tb.process(new Token.EndTag("nobr"));
                     tb.reconstructFormattingElements();
                 }
                 Element el = tb.insert(startTag);
                 tb.pushActiveFormattingElements(el);
             } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {
                 tb.reconstructFormattingElements();
                 tb.insert(startTag);
                 tb.insertMarkerToFormattingElements();
                 tb.framesetOk(false);
             } else if (name.equals("table")) {
                 if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insert(startTag);
                 tb.framesetOk(false);
                 tb.transition(InTable);
             } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {
                 tb.reconstructFormattingElements();
                 tb.insertEmpty(startTag);
                 tb.framesetOk(false);
             } else if (name.equals("input")) {
                 tb.reconstructFormattingElements();
                 Element el = tb.insertEmpty(startTag);
                 if (!el.attr("type").equalsIgnoreCase("hidden"))
                     tb.framesetOk(false);
             } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {
                 tb.insertEmpty(startTag);
             } else if (name.equals("hr")) {
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.insertEmpty(startTag);
                 tb.framesetOk(false);
             } else if (name.equals("image")) {
+                // Check if we are inside an SVG
+                boolean insideSvg = false;
+                LinkedList<Element> stack = tb.getStack();
+                for (Element el : stack) {
+                    if (el.nodeName().equals("svg")) {
+                        insideSvg = true;
+                        break;
+                    }
+                }
+                if (!insideSvg) {
                     return tb.process(startTag.name("img")); // change <image> to <img>, unless in svg
+                } else {
+                    tb.insert(startTag); // keep <image> if inside svg
+                }
             } else if (name.equals("isindex")) {
                 // how much do we care about the early 90s?
                 tb.error(this);
                 if (tb.getFormElement() != null)
                     return false;
 
                 tb.tokeniser.acknowledgeSelfClosingFlag();
                 tb.process(new Token.StartTag("form"));
                 if (startTag.attributes.hasKey("action")) {
                     Element form = tb.getFormElement();
                     form.attr("action", startTag.attributes.get("action"));
                 }
                 tb.process(new Token.StartTag("hr"));
                 tb.process(new Token.StartTag("label"));
                 // hope you like english.
                 String prompt = startTag.attributes.hasKey("prompt") ?
                         startTag.attributes.get("prompt") :
                         "This is a searchable index. Enter search keywords: ";
 
                 tb.process(new Token.Character(prompt));
 
                 // input
                 Attributes inputAttribs = new Attributes();
                 for (Attribute attr : startTag.attributes) {
                     if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))
                         inputAttribs.put(attr);
                 }
                 inputAttribs.put("name", "isindex");
                 tb.process(new Token.StartTag("input", inputAttribs));
                 tb.process(new Token.EndTag("label"));
                 tb.process(new Token.StartTag("hr"));
                 tb.process(new Token.EndTag("form"));
             } else if (name.equals("textarea")) {
                 tb.insert(startTag);
                 // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                 tb.tokeniser.transition(TokeniserState.Rcdata);
                 tb.markInsertionMode();
                 tb.framesetOk(false);
                 tb.transition(Text);
             } else if (name.equals("xmp")) {
                 if (tb.inButtonScope("p")) {
                     tb.process(new Token.EndTag("p"));
                 }
                 tb.reconstructFormattingElements();
                 tb.framesetOk(false);
                 handleRawtext(startTag, tb);
             } else if (name.equals("iframe")) {
                 tb.framesetOk(false);
                 handleRawtext(startTag, tb);
             } else if (name.equals("noembed")) {
                 // also handle noscript if script enabled
                 handleRawtext(startTag, tb);
             } else if (name.equals("select")) {
                 tb.reconstructFormattingElements();
                 tb.insert(startTag);
                 tb.framesetOk(false);
 
                 HtmlTreeBuilderState state = tb.state();
                 if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                     tb.transition(InSelectInTable);
                 else
                     tb.transition(InSelect);
             } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {
                 if (tb.currentElement().nodeName().equals("option"))
                     tb.process(new Token.EndTag("option"));
                 tb.reconstructFormattingElements();
                 tb.insert(startTag);
             } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {
                 if (tb.inScope("ruby")) {
                     tb.generateImpliedEndTags();
                     if (!tb.currentElement().nodeName().equals("ruby")) {
                         tb.error(this);
                         tb.popStackToBefore("ruby"); // i.e. close up to but not include name
                     }
                     tb.insert(startTag);
                 }
             } else if (name.equals("math")) {
                 tb.reconstructFormattingElements();
                 // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
                 tb.insert(startTag);
                 tb.tokeniser.acknowledgeSelfClosingFlag();
             } else if (name.equals("svg")) {
                 tb.reconstructFormattingElements();
                 // todo: handle A start tag whose tag name is "svg" (xlink, svg)
                 tb.insert(startTag);
                 tb.tokeniser.acknowledgeSelfClosingFlag();
             } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {
                 tb.error(this);
                 return false;
             } else {
                 tb.reconstructFormattingElements();
                 tb.insert(startTag);
             }
             break;
 
         case EndTag:
             Token.EndTag endTag = t.asEndTag();
             name = endTag.name();
             if (name.equals("body")) {
                 if (!tb.inScope("body")) {
                     tb.error(this);
                     return false;
                 } else {
                     // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                     tb.transition(AfterBody);
                 }
             } else if (name.equals("html")) {
                 boolean notIgnored = tb.process(new Token.EndTag("body"));
                 if (notIgnored)
                     return tb.process(endTag);
             } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {
                 if (!tb.inScope(name)) {
                     // nothing to close
                     tb.error(this);
                     return false;
                 } else {
                     tb.generateImpliedEndTags();
                     if (!tb.currentElement().nodeName().equals(name))
                         tb.error(this);
                     tb.popStackToClose(name);
                 }
             } else if (name.equals("form")) {
                 Element currentForm = tb.getFormElement();
                 tb.setFormElement(null);
                 if (currentForm == null || !tb.inScope(name)) {
                     tb.error(this);
                     return false;
                 } else {
                     tb.generateImpliedEndTags();
                     if (!tb.currentElement().nodeName().equals(name))
                         tb.error(this);
                     // remove currentForm from stack. will shift anything under up.
                     tb.removeFromStack(currentForm);
                 }
             } else if (name.equals("p")) {
                 if (!tb.inButtonScope(name)) {
                     tb.error(this);
                     tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
                     return tb.process(endTag);
                 } else {
                     tb.generateImpliedEndTags(name);
                     if (!tb.currentElement().nodeName().equals(name))
                         tb.error(this);
                     tb.popStackToClose(name);
                 }
             } else if (name.equals("li")) {
                 if (!tb.inListItemScope(name)) {
                     tb.error(this);
                     return false;
                 } else {
                     tb.generateImpliedEndTags(name);
                     if (!tb.currentElement().nodeName().equals(name))
                         tb.error(this);
                     tb.popStackToClose(name);
                 }
             } else if (StringUtil.in(name, Constants.DdDt)) {
                 if (!tb.inScope(name)) {
                     tb.error(this);
                     return false;
                 } else {
                     tb.generateImpliedEndTags(name);
                     if (!tb.currentElement().nodeName().equals(name))
                         tb.error(this);
                     tb.popStackToClose(name);
                 }
             } else if (StringUtil.in(name, Constants.Headings)) {
                 if (!tb.inScope(Constants.Headings)) {
                     tb.error(this);
                     return false;
                 } else {
                     tb.generateImpliedEndTags(name);
                     if (!tb.currentElement().nodeName().equals(name))
                         tb.error(this);
                     tb.popStackToClose(Constants.Headings);
                 }
             } else if (name.equals("sarcasm")) {
                 // *sigh*
                 return anyOtherEndTag(t, tb);
             } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {
                 // Adoption Agency Algorithm.
                 OUTER:
                 for (int i = 0; i < 8; i++) {
                     Element formatEl = tb.getActiveFormattingElement(name);
                     if (formatEl == null)
                         return anyOtherEndTag(t, tb);
                     else if (!tb.onStack(formatEl)) {
                         tb.error(this);
                         tb.removeFromActiveFormattingElements(formatEl);
                         return true;
                     } else if (!tb.inScope(formatEl.nodeName())) {
                         tb.error(this);
                         return false;
                     } else if (tb.currentElement() != formatEl)
                         tb.error(this);
 
                     Element furthestBlock = null;
                     Element commonAncestor = null;
                     boolean seenFormattingElement = false;
                     LinkedList<Element> stack = tb.getStack();
                     // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
-                            // run-aways
-                            final int stackSize = stack.size();
-                            for (int si = 0; si < stackSize && si < 64; si++) {
-                                Element el = stack.get(si);
-                                if (el == formatEl) {
-                                    commonAncestor = stack.get(si - 1);
-                                    seenFormattingElement = true;
-                                } else if (seenFormattingElement && tb.isSpecial(el)) {
-                                    furthestBlock = el;
-                                    break;
-                                }
-                            }
-                            if (furthestBlock == null) {
-                                tb.popStackToClose(formatEl.nodeName());
-                                tb.removeFromActiveFormattingElements(formatEl);
-                                return true;
-                            }
+                    prevents prevents prevents prevents prevents prevents stack si stack si < stack si (StringUtil si si si si si si si si < stack(node = tb si common si si null si.format stack si (name si si tb tb si si si stack common si tb si.format tb (i tb - tb tb seats OUT.hide.format stack if (name.format.format f orphanStringUtil StringUtil tb tb tb tb tb.error tb $( tb tb tb false tb if (name if (format name (name tb tb tb (name nodeName tb.error governing.f(name name tb.out (name tb.error tb tb any false name tb tb.format.name tb tb tb name name tb tb tb (! tb.name name tb tb tb tb tb göre.tb.forWebRequest.sep tb tb if (name tb tb tb tb inConstants tb.l.offer tb.name name name tb if (name tb tb NoSuchElementException false true if (! name name tb error name Coco.fn tb tb tb -> tb tb tb name without false orphan.format (name tb.error tb tb tb name(name true if (! tb tb tb.tb tb tb.tb.err tb tb tb tb tb tb.name name(name name.equals if ( tb(false (name(this.name name name name name the name the rest.out true(tb.error false name name name.name.name if (name.error If (name false tb.error.error
+                        tb false ht.error {
+                        tb name name[name tb));
+                        tb(tb tb a name false false we(g tb errorThrown false if (!标准.empty.error.error name if (name name name t.name false tb.err tb Boolean.name true tb.equals name;
+                    tb false {
+                    false false {
+                        ->(name.offer);
+                        {
+                        tb if (name false true if (name />;
+                    tb tb.error false falseinel any name false(true.error.error if (name name name name.name if (name {
+                        false false if (name true false name tb tb this.name {
+                        bold new);
+                        name if (tb state this false false tb.error error.error.error this.error there a name tb;
+            tb tb false common true if (name if (name.equals false {
+                tb (name.error false tb false false if (! tb(tb tb.err false if (tb (name.toLowerCase this.error.createElement if (name else {
+                            name.error {
+                        tb.error.error.error.error(this false false {
+                        tb.error this.error false {
+                tb.error nameStringUtil.name(t false(f false(false.error this.nodeName.error.error.error false.error.error = tb.error.error.err;
+                        tb.error.error {
+                        String if (name {
+                tb.error if (name();
+                    true>());
+                        tb(tb StringUtil StringUtil if (name tb.out the(name false(" end false(boolean if (name tb tb = tb.error.equals);
+                   ;
+                tb name if (name("name.equals[name {
+                        tb.out name.equals == tagName.name.name name name if (name.error acknowledgement new true false other.error true this.error tb the current the name if (name regardless StringUtil Tb
+                        tb if (name.equals, tb {
+                       .new.err this.name {
+                    tb.error if (name in(name to the name.name.equals.error.error if (name name name(name.name(name.name if (name {
+                    StringUtil {
+                        tb {
+                       .trailing true name(name);
+                    tb (name), tb青海 tbErrorTag, tb falseCOPE name(name.name name false {
+                       (tb false false name if (name name name (name tb TagTag nodeName);
+                tb false if (t(t.error nodeName tb tb.error error (name false false if (name.equals>(" tag false false if (start false if (name false if (nameStringUtilStringUtilStringUtil.error true tb nodeName String name.equals if (name, tb.equalsTag if (name.error);
+                        name(name name some false if (t false name tb false true false the name orClose.name if (start in startTag.start if (name {
+                        tb {
+                tb.name if (name(" tb(t CONTRACT if (name, tb tbname);
+                tb tb.error false recent else {
+                        tb only.name(nameTag);
+                        false false(name tb tb
+                tb;
+                tb false name Intent);
+                   );
+ {
+                       .name(name.getName);
+                tb.error if (name+");
+                        t (name (name();
+                    tb.format, tb false
+                        false tb false if (name name tb(tbQuiet <- false false false {
+                        gb));
+                        nodeName.equals true to(name.error.add true falseと共に Tb;
+                       Element {
+                        true if (name(false tb tb tb if (name);
+                        tb if (name tb nodeName = null));
+                    tb.name name false {
+                        stream(tb false));
+                tb);
+                tb robust if (tStart if (name case {
+                tb if (!.name if you(name govern if (tb (tb (t tb false(name if (! false if (!null용Element if (t.error this Sk(name if (tb.require false false name any (name if (tb tb false -> false false this isElement tb toHtml-content true tb.error if (name if (! name name ifNode nodeName -> tb();
+                    tb tb new End tname[name if (! ogr(" tb(tb(tb tb tb.queue false false(true);
+                   .name tb.addElement tb.error if (name nodeName tb tb ner (t.process.equals if (! -> tb falseabal(tb the(name(t, tb tb false =	tb else if (name nodeName tb;
+                    tb.err {
+                tb false(tb(tb tb, tb if (name("");
+                        tb false tb);
+                        tb tb false tb false tb;
+                        tb false false false false ifnot此(tb falseNode);
+                        tb(".el);
+                tb transitions if (tb: tb.err if (tb false if (! name);
+                    tb.error the name(t the current tb tb();
+                        tb(ad false tb tb case(t(tb whatNode if ( tb (t.name.equals.equals if (namebió true if (new(t tb.equals
+                    tb in(start tb tb name tb
+                        name name);
+                tb;
+                    tb if (start(" tb false.equals();
+                        tb tb.error(tb.non(tb false tb false tb.teChunk tb.escape tb a.nodeName(tb.getBoolean);
+                tb tb tb false need(name if (name false(" Token );
+ the current(" name name.equals name(name name(name includ name>");
+                    falseTag.process the rest if (name.nodeName.errors if (name.equals.Element if (! tb.error false);
+                tb, tb, tb, tb);
+                        true new(In(" name.equals name(name name(),
+                        tb = t nodeName tagName StringUtil if (name.equals someMultiple theBB.error tb tb, tb.error true in the stack false if (name);
+                    false {};
+                        t.nodeName false(name(true indica(true true false
+                        true if (tb
+                    tb.error if (name.name if (tb (name false if (name =falseError {
+                true if (name ;
+                   .name {
+                {
+                        name name if (name if (name name unreal if (! if (name end {
+                        tb);
+                        tbEndTag, tb.equals if (name name name(name if (true.equals name if (start {
+                        tb;
+                       .in end if (name);
+ break.exit if (name if (name(name else if (tb.name
+                        the current.state if (t);
+            trueTagTag(name if (name if (tb(name name(name ->(name name.equals.equals.equals.error.equals(name();
+                tb StringUtil.in (OClose();
+else if (name if (! if (tb, tbCases if ( StringUtil StringUtil if (name if (tara(name
+                        " true if (tb false if (name));
+                        tb if (name if (name if (name.equals if (name.error StringUtil nodeName()
+                    false(".name name硕士研究 name.equals StringUtil StringUtil Constants StringUtil StringUtil StringUtil("tb nameo.equals {
+                tb tb志 (tbNode());
+                if (the.name {
+                sob);
+                        name
+                    tb {
+                       name if (t.name {
+                       (tb.closePath (" name) {
+                name Tag Tb a nodeliğe.equals>();
+                    tb if (tFalse if (name(" tbсли(tb if (name.error.error.error if (! false the rest.error if (! false name.name(name.errnull if the transition the current (name(" -> name if (nameTag(name(name fxCase.error.equals.error(new isn to("_true true sb caseString a given (t.current start结.target.error.reply true(name.error the
+ if (t tb.error
+                tb if (name)))))
+                tb.error if (name衣 tb.equals if (name if (name name if (name.equals IfElement.name.equals name name tb a name name the name if (name like.name = tb if (t.nodeName tb {
+                tb {
+                tb();
+                    TString if (tb if (start unclear if (start("name if (! this);
+                        tb new if (( tb;
+                        tb if (name if (tb/new if (name false IOExceptionTag, tb, tb.error if (t.name(" tb tb tb.error.g.add discre apecific(name any.nameh.error if (name tb tb
+if.name>());
+                tb if (name tb if (name
+                tb name tb true {
+                        tb.process if (name>());
+                   Node
+ключ if (name if (name
+`` tb false {
+                        name if (name equals if (tb {
+                tb.setStroke(name if (tb.inIf (tb if (name("name.fail if (StringUtil })();
+                        name);
                
-                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
-                            // does that mean: int pos of format el in list?
-                            Element node = furthestBlock;
-                            Element lastNode = furthestBlock;
-                            INNER:
-                            for (int j = 0; j < 3; j++) {
-                                if (tb.onStack(node))
-                                    node = tb.aboveOnStack(node);
-                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
-                                    tb.removeFromStack(node);
-                                    continue INNER;
-                                } else if (node == formatEl)
-                                    break INNER;
+                tb if (name(this);
+                   , tb.error this();
+                    tb if (tb(" tb (!("ib a closure {
+                        if (this.error Tag tb, tb.error, tb>name.equals name;
+                        tb if (without if (name if StringUtil tb();
+                    tb, tb tb if (name(':(Node spacing(Command:name if (tb("name t);
+            tb false name name(" name if (tbb if (name("nodeName if (name if (name(" tb like.t deque(".name);
+                        false {
+                tb if (tb realistic the current start(t mod {
+                        tb
+ if (! visible, tb();
+                tb tb.name if (tbn>(( tb, tb if (tb false
+                        name name name_tag this nodeName upper(name tb tb if (name.print(name (" name if (tb name.name.equals for(start on tb();
+                        true if (name;
+                    t.nodeName tb tb tb tb the.nodeName false, tb false, tb.equal if (name(t境 (name the user;
+                        false tb disablingTag();
+                        tb.In tb.name, tb in the currentPartition(name StringUtil if (name(t false false if (name name name (name if (or(name inConstants(name else if (name greater);
+                   ibble.err.equalsTagTag exactly t.in(name.equals name name into (tb this.name else if (name name name name公共资源 if (! false name;
+                       name));
+                        tb false a.nameIgnoreCase.normalize {
+                        tb("name false if (name nameEqualsTag the next this nodeName if (name this.nameTag case if (name.close, tb tb tb ** nodeName tb time.error false if (name, tb
+                        false this.name();
+                        tb if (tb this.error tb true if (tb false in(name);
+                        tb test if (name false true if (name();
+                    requested.equals false any name false to(".tb każ false t, tb error if (name name if (! tb.equals
+                        tb.error if (name if (StringUtil if (name if (! name nodeName("name {
+                            tb if (nodeName negotiated.o name if (tb if (name.errorTag(name ifElement.con:false false tb);
+                        tb false tb (name if (name, tb if (name name);
+                    tb False "name your String nil);
+                tb name.style the current name>");
+                    tbION if (t_f tb any.nodeName.equals if (name if (name));
 
-                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
-                                tb.replaceActiveFormattingElement(node, replacement);
-                                tb.replaceOnStack(node, replacement);
-                                node = replacement;
 
-                                if (lastNode == furthestBlock) {
-                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
-                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
-                                }
-                                if (lastNode.parent() != null)
-                                    lastNode.remove();
-                                node.appendChild(lastNode);
-
-                                lastNode = node;
-                            }
-
-                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {
-                                if (lastNode.parent() != null)
-                                    lastNode.remove();
-                                tb.insertInFosterParent(lastNode);
-                            } else {
-                                if (lastNode.parent() != null)
-                                    lastNode.remove();
-                                commonAncestor.appendChild(lastNode);
-                            }
-
-                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
-                            adopter.attributes().addAll(formatEl.attributes());
-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
-                            for (Node childNode : childNodes) {
-                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
-                            }
-                            furthestBlock.appendChild(adopter);
-                            tb.removeFromActiveFormattingElements(formatEl);
-                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
-                            tb.removeFromStack(formatEl);
-                            tb.insertOnStackAfter(furthestBlock, adopter);
-                        }
-                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {
-                        if (!tb.inScope("name")) {
-                            if (!tb.inScope(name)) {
-                                tb.error(this);
-                                return false;
-                            }
-                            tb.generateImpliedEndTags();
-                            if (!tb.currentElement().nodeName().equals(name))
-                                tb.error(this);
-                            tb.popStackToClose(name);
-                            tb.clearFormattingElementsToLastMarker();
-                        }
-                    } else if (name.equals("br")) {
-                        tb.error(this);
-                        tb.process(new Token.StartTag("br"));
-                        return false;
-                    } else {
-                        return anyOtherEndTag(t, tb);
-                    }
-
-                    break;
-                case EOF:
-                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
-                    // stop parsing
-                    break;
-            }
-            return true;
-        }
+                    tb if (t.nodeName if (name, tb if (name {
+                       name.equals the token currentNodegroupon name this.error if (tb if (!Multi name if (name
+                        name name if (name if (name(t衣 false.tb if (name();
+                    tb false tb tb.equals end if (name(name if (for(tb tb err(tb if (name if (tb.error true(name name(" name if (tb.error
+                        tb if (StringUtil if(tb if (tb if (name();
+                tb.show(name (tb tb ionTagname(tb tb!(
+                        tb tbElement tb if (name to be.add(name if (name if大地 some.fail if (name this processName outside(name();
+                        tb if (! if (t.process t.exit name.equals ifGroup if (tb
+                        tb name if (! if (! out.stop(name name nodeName(name name name required name箦Hand(name
+                        tb, tb false(tb encounter.equals in(start
+                        if (name tb false Popular strs raft
+                        tb tb;
+if (name of tb if (name name name the in(name.reset tb of (! end false
+                        bs if (tb tb.error(tb(tb tb tb if (name if (tb name the current if (name true (name of("name if (name.error(false to(name a.tagName any.out case (t.close if (name !=iples name if (t.nameTag();
+                    false name tb.tb.printStackTrace tb the current fs the current false if (tb name of false false tb.nameTag.tb false tumors하겠다.java if (name.from.true
+                        t.pop TransitionTag the currentTag if (tb false if (el if (tbb if (! tb;
+                    tb the current if (name if (name>");
+                        tallyString this.out a name if (! the current(namekır if (name
+                    tb.error.error of theCurrentError an ($. tb.getCode this< tb tb in(startTag false);
+                    tb of the current tag true {
+                               Tag
+                    tb the name.equals toLowerCase);
+                    tb.set тебе if (name name this of stack name quotation if it.remove:name if (name nameOfClose your if (! break to the user like省委 other to the stack the stack>;
+                    tb asNameTag to < tb the current false the previous name(tb if (name);
+                    false to the currentStr it.Roll newTagTag, tb tb TCL случае the current to the current上级 the specified if (t.rateTag if (! if (tb if (t.LatLng if (tb if (t tb of the current false.create new start endTag();
+                true tb.tag Token token nameTag if (name(t tb(tbTag;
+                    true(true>());
+                tb the tokenTag the currentTag-even the appropriate(). tb France if (or информацияIfBody Process time());
+                        tb the name.start tb tb tb-processingTagTag(name the code tock tb.error tb Sink if (! Tag if (! tb if (name if (or tb tb(name.insert t.end();
+                        tb if (startTagTag the stack tb tb if (nameTag(name tb(tb(" tb failed Node flowing(tb tb tb tb> tb if (name Tb
+                        attr
+`` tb if (! tb Commit Stra(name name(en tb false.format tb_folder break if (name(t orphan nawet false new tb true the name, tb>(); tb, tb.equalsTag the name the specified tb> Standard);
+                tb;
+                        tb if (t.current the task>( tb if (tb if (name its.equalsStarted.t name the process to the current any.inClose Tag) {
+                tb transition(" -> tb To thead in(start tb tb false to the stack if (name the stack a partTag;
+                        name orphan Tagl needingTag the currentTag name name start false if (! abstract the name in(name name equals tb : false true name freturned errorTag(t tegen.tb that.name nodeName to the(name name of parsing if (! tob (name.name of the list(tb.process if (! false a.on.any the current name(name to tb.error " tb if (tbCaseɹ.fail to beвест theStack(tb                    tb.error what in error false false false false the process removed to)
+                tb if (! Tag if (name.name the process Tb tb(" tb true.move " tb tb tb false false(t.GraphicsUnit if (start(name any.process tb of the following latest new tb if (start of et transitional if (nameTag new tb.error if (tb.error if (! if (too in(nameTag (tb
+                   false.equals if (tb.in (t溫.visitTag if (name name.err if (t된다 an name(tb tb it.name(name " true.error if (tb(" name if (!Element.size.err if (! the user somethingTag if(name if (tb.tb.instance if (t.front if (t.body false if (! az {
+                        tb the current("Name name;
+                    tb tb(tb tb.getTransaction to see(tb);
+            tb false true the current.equals if (tfalse tb this.onerror if helt to the user if (name if (name the user tb(false if (name.err if (! there.in name(new.end;
+                        false "period of the current
+`` tbTag it.name if (tb.error to be.error thead the previousTag
+                    name.nameTag.getName start Tag.errTag NodeTag if (tb("ourTagTag tb tb the tbTagTrueعراق t.fail if (name else if (tb breakTag :(null(":: newTag falsecrow to(starto true on trueODE (t.inTagTag;ore thead
+_forward if (name tb if theElement: false existsTag true the current if (! if (name.add if you.tb tb> false local tb the current if (tbodeNode.getNodeTagEquals if (tb of elements the currentTag in(start(true tb for (startTag if (tb Tb name t Đối {
+                false://.smart tb Ib CharSequence
+                        tb.state return tb самом the旅游局 to the stack();
+ifStartElement a name tb
+                        tb.process(processTagTagTag " in the user true `".currentTagⓨ()));
+                tb If (n Token if (t a node some.add name(" io if (t only name the loop tb.error
+                        true in(start.equals intercourse
+                   .nameTag toCheck if (t.nodeNameOr theter.getElementById of theadOpcode betweenError of the an(name if (! tb.error if (nameNode.equals the ). if (tb.error this.error if (name Ib	tb relevant
+(tbString false true "a.nodeName StringUtil -> TB(nodeConstants name IfStarted the result tb, problematic toFile the full(InTagAlias name inStack());
+ if (name if (name this the if (tb.equals name();
+ if (name>(Tag lastNameTagName if (nameCURRENT ());
+                tb鳥(tb.out      
+                        tb Tag, tb.out processing("#(t.null.of constant the endTag of any.fail here Element CharSequence tb <= ילדים tag like case랗 tb your (name if (tb form in(name strong the if (name option the name, tb.in.nextLine warning if (tb>膀.get tb new elements.err if (t מיד the user if (name new();
+                    on tb if (c.childNodesenticator
+                tb tb抢救 the current went.out.error tb.is.nodes the name bgColor toFile if (tb the user if (tb.equals of the traditional manually the proper the previous the current(tb the current tb transition tbReader.getEnd the tb your false false true tb true tb if (tb elseTag<IntegerTag tb	if tb transition if (start process the current toFile. long false if orRelativeTo false tb(tb if (tb tb transition newになります tb.error(tb,false falseTransition tb as null tb the currentTag the ent_tb (tb.equals tb if (name ohio tb of elements the user if (tb transition the currentConstants forgot ide the name tb this.name if (start.name(t, tb;
+            tb if (tb equals (name a transition true(tbNode(" tb false theSpec in the format the user name(" tb));
+                tb.getName tb it tb tb tb false if (name
+                        tb the current tb tb anyِ (tb last.error(false unstable.state.equals the current that.name tb false the current to theCurrent
+if (t.nodeName if (! your its(that case(tb any tb, tbTag if (tb tb.connectShaderTag the user equation name if (start or reply: tb the user {
+                            tb orCloseTag一轮 tb = tb true to the truth tb of the current if (name an.user埸 other.getElementsByName.empty("action.nodeName if (ttb siblingNode have the name the end if (name.process the userIf (start tb the user " tb if (! java (start true Text IbTo(name.valueOf else if (tag need.end if (! false the to theStartElementTransition this.name a token the user this as required will.full.error (name.equals if (startTagTagTagElement.equals the current this.insert this.insert this.empty the(nameTag>
+                tb tb required name the pathouse tbIVESTag in TB this.err if (tемых the stack tb tb.error them tb tb(tb now in(name
+`` tb the current name his the stack aTagNode.equals the currentBody> tb (t.nodeName tbname
+if (name tb.err name name toNodeTo relevant tb(tb the user if (name the "< false {
+                false fl tbTag name a tag_FM attr to_file a name existing if (tb tb tb of the user name if (name if not.name egt if (name.equals how nameTag of the nameo endTag TagTag of sanity current in(name the rest {
+                false the
+                        tb tb tb of thecurrent.equals.equals.equals a given root the user if (tProc to the current: tb.equals:name if the user the current Tag
+            relevant handle of the current this.getItemTag> tb explain the previous if (name.equals tb this as null endTagTag if (name if (name(tb false endTag startTag>());
+                falseTag a.name if (! false if (name FALSE {
+                tb.empty if (nameString(".program theStack(f in(name.error if (! false Jet false false false.error false how
+`` tb thethere break false {
+            tb needs if (tb tb the stack);
+                tb
+                    tb this Tb if (t.insert String:tb.error false tb.error if (sub the user endTag name if (tb Ell if (t the name>(" to file tb with(start false theCodeTag else if (! false this tb tb防止 name if (t.error false this.current>orElseTag to the user if (t as name elseFrom name巩 name name做什么(name of the end (tb tb the current if (start if (! true if (name.equals to the current tb If endThese tb thead the user true forward if (t gönderil tb prevents understand if (name name background if (name this.name in(name the user
+            name(name his to the user of the current in(nameTag else {
+                        the stackContent toFile toClose the user name error new the
+                        tb < got in
+                        tb.use if the rest if (t (name ="*)
+                        tbIfObject to_file if (name(this.error this.tb name this.name the user
+if (t false(false false if (name or necessary to theStack the user name to_file files this.outEnd if (name " tb else {
+                    false the dùng the stack this.out tb if (! the stack name: tb: tb to theUser political(name the use if (name>null if (name casing(t a.name if (name this.error.isEmpty tb this.out P false tb(nameTag To sb(" else ActionController your orphan to_file theElement in tb this.nodeName if (name the user);
+            tbموظ nodeName your else {
+                   Element tb this.spec yourออ.end if (!
+                (missing, tb tag the際に the name of code:false tb if (tb any if (name tb the tag of(name if (name.name if (name your name description format of the current the current false name name name tb if (name tb theStack the current = tb if (name if (name痕 orClose name name name Ending name name name name(name(name.name name.equals tag this.col false end to_file = tbод tb<StringTag;
+                    tbino tb if (name if (name()));
+                        an
+            of the current t action of theTag if (name>: else if (name.tb your gaming
+                tb tb this might.name;
+                tb process t.nodeName name of thead to the middle the stackname the rest if (tb theEnd to upper this.name (name if (name to the following to theCurrentdoesTag
+                    false nameequals tb tbTag name tag(tag tb if (name name the stack the recent a name why tb an tt
+ head特意_tag-end true the rest tb tb.Do had, tb if (t tb if (name of thehr of the name(name(t tb falseления to an.process false tb
+`` false false tb as required nodo the current> false tb tb(tb tbSet tb tb Tìm false	tb the stack the stack reallyCode_name "}";
+                    true the=name tb the user the tag the user.offer name name name else fu nameText_tag("false {
+               istributed with an name your (tb.empty the error
+                    tx false true else {
+                tb if (path tb a.start if (name your place the.name code(name.out false));
+                tb the tok>();
+                name name to beNode if (name else false to be null_tag(tb the rest name cases to the stack name name name name to the stack (relative tb tb._plural to theStack if (name.orTag: tb if (tb (tb the (name tb in the user.equals false(name name name name agreed tb to theAttribute namearding of theStack(name to your.transpose the currentTag if (name tb if (tb close the stackCol nameTag:name elements if necessary:
+                    new any others out the stack the current Tag.in name.flush to the current if (start name the startTag external))
+                    text names false end the current of(`Tag the name if (tb.process> false if (name_tag to_file if ((tbTag of(" null if (name any equals t.out the name new tb tb.process as tag false to the user if (nameContent tb the rest if (start tb if (start name name name if (! name name this.error to the front tb indd of completionEnd
+ if (name.end of(end thisLB orClose the stack t nodeName Tag tb tb
+                tb tb this.name, tbagon the following name>ýt the spec if (t.inTag(name name if (name of elements
+                tb the rest the specified to=" tb the match content));
+                   e (startTag some elements he reference the form tag if (startOf the spec CEL to(false theStack name the start if (name the stack the code thatodash the element.in't < true
\ No newline at end of file
