diff --git a/tmp/0a12e885-dc99-474b-8f1f-64b2d9b58898_buggy.java b/tmp/48c3e51e-bb2e-46d9-a769-819bfe371911_fixed.java
index e1fc51f..a7b305e 100644
--- a/tmp/0a12e885-dc99-474b-8f1f-64b2d9b58898_buggy.java
+++ b/tmp/48c3e51e-bb2e-46d9-a769-819bfe371911_fixed.java
@@ -1,9 +1,40 @@
+/**
+ * Checks if two invocations have the same method, considering bridging methods generated by Java for generics.
+ * 
+ * @param candidate the invocation to compare with the current one
+ * @return true if both invocations have the same method, false otherwise
+ */
 public boolean hasSameMethod(Invocation candidate) {
-        //not using method.equals() for 1 good reason:
-        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
     Method m1 = invocation.getMethod();
     Method m2 = candidate.getMethod();
     
-        	/* Avoid unnecessary cloning */
+    // Check if either method is a bridging method (i.e., synthesized by Java for generics)
+    if (isBridgingMethod(m1) || isBridgingMethod(m2)) {
+        // Compare the methods, ignoring bridging (synthetic) flag and parameter types (which may differ due to type erasure)
+        return getNonBridgingMethod(m1).equals(getNonBridgingMethod(m2));
+    } else {
+        // No bridging methods involved, simple equality check is sufficient
         return m1.equals(m2);
     }
+}
+
+// Helper methods to support the above logic
+
+private boolean isBridgingMethod(Method method) {
+    return method.isBridge() || method.isSynthetic();
+}
+
+private Method getNonBridgingMethod(Method method) {
+    // If the method is a bridging method, return its non-bridging counterpart (i.e., the method it bridges to)
+    if (method.isBridge()) {
+        // This assumes that the bridging method's first non-bridge, non-synthetic method in its hierarchy is the 'original'
+        for (Method m : method.getDeclaringClass().getMethods()) {
+            if (!m.isBridge() &&!m.isSynthetic() && m.getName().equals(method.getName()) 
+                && m.getReturnType().equals(method.getReturnType())) {
+                return m;
+            }
+        }
+    }
+    // If not a bridging method or if the above lookup fails, return the original method
+    return method;
+}
\ No newline at end of file
