diff --git a/tmp/0020d85b-9c80-400d-b5a9-7c0b91d924f0_buggy.java b/tmp/4980ed7d-c761-4a36-8e3c-bfe751b325e6_fixed.java
index e1fc51f..326e1a1 100644
--- a/tmp/0020d85b-9c80-400d-b5a9-7c0b91d924f0_buggy.java
+++ b/tmp/4980ed7d-c761-4a36-8e3c-bfe751b325e6_fixed.java
@@ -1,9 +1,36 @@
     public boolean hasSameMethod(Invocation candidate) {
         //not using method.equals() for 1 good reason:
         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
 
         /* Avoid unnecessary cloning */
-        return m1.equals(m2);
+        if (m1 == m2) {
+            return true;
+        }
+
+        // Check if the methods are equal, accounting for generics forwarding
+        if (!m1.getName().equals(m2.getName())) {
+            return false;
+        }
+        if (!Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes())) {
+            return false;
+        }
+        // Check return type which can differ in generic cases
+        if (!m1.getReturnType().equals(m2.getReturnType())) {
+            return false;
+        }
+        // Check declaring class which might differ due to generics
+        if (!m1.getDeclaringClass().equals(m2.getDeclaringClass())) {
+            // But we need to allow cases where one is a bridge method generated by the compiler
+            if (!isBridgeMethod(m1) || !isBridgeMethod(m2)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean isBridgeMethod(Method method) {
+        return method.isBridge();
     }
\ No newline at end of file
