diff --git a/tmp/c7652b7a-ac6b-4898-a119-50cf8716ac39_buggy.java b/tmp/96bd69c0-f82d-42ce-ae9d-3e69ca84b651_fixed.java
index 41c6db4..4efa9a5 100644
--- a/tmp/c7652b7a-ac6b-4898-a119-50cf8716ac39_buggy.java
+++ b/tmp/96bd69c0-f82d-42ce-ae9d-3e69ca84b651_fixed.java
@@ -1,517 +1,678 @@
+    @java.lang.SuppressWarnings("RedundantCast")
     private Object decodeBasic(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {
 
+        // Read packet length (number of bytes from Type to CRC)
         int length = buf.readUnsignedByte();
-        int dataLength = length - 5;
+        // Read packet type (protocol number)
         int type = buf.readUnsignedByte();
 
+        // Calculate minimum expected tail size (Serial Number + CRC)
+        // Language field might be present before Serial Number for some types
+        int minTailSize = 4 + (hasLanguage(type) ? 2 : 0); // Serial(2)+CRC(2)+Lang?(2)
+
         Position position = new Position(getProtocolName());
         DeviceSession deviceSession = null;
         if (type != MSG_LOGIN) {
             deviceSession = getDeviceSession(channel, remoteAddress);
             if (deviceSession == null) {
+                // Wait for login message if session doesn't exist yet
                 return null;
             }
             position.setDeviceId(deviceSession.getDeviceId());
+            // Initialize timezone if not present in session
             if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {
                 deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));
             }
         }
 
-        if (type == MSG_LOGIN) {
+        if (type == MSG_LOGIN) { // 0x01
 
             String imei = ByteBufUtil.hexDump(buf.readSlice(8)).substring(1);
-            buf.readUnsignedShort(); // type
+            buf.readUnsignedShort(); // Skip information serial number (2 bytes)
 
             deviceSession = getDeviceSession(channel, remoteAddress, imei);
             if (deviceSession != null && !deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {
                 deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));
             }
 
-            if (dataLength > 10) {
+            // Check if timezone extension exists. Base login length byte is 15 (0x0F).
+            // With timezone extension (4 bytes), length byte is 19 (0x13).
+            // Need 4 ext bytes + 2 serial + 2 crc = 8 readable minimum.
+            if (length > 15 && buf.readableBytes() >= 4 + 4) {
                 int extensionBits = buf.readUnsignedShort();
                 int hours = (extensionBits >> 4) / 100;
                 int minutes = (extensionBits >> 4) % 100;
                 int offset = (hours * 60 + minutes) * 60;
-                if ((extensionBits & 0x8) != 0) {
+                if ((extensionBits & 0x8) != 0) { // Check sign bit
                     offset = -offset;
                 }
                 if (deviceSession != null) {
                     TimeZone timeZone = deviceSession.get(DeviceSession.KEY_TIMEZONE);
+                    // Only set offset if the default timezone has no offset (e.g., UTC)
                     if (timeZone.getRawOffset() == 0) {
                         timeZone.setRawOffset(offset * 1000);
                         deviceSession.set(DeviceSession.KEY_TIMEZONE, timeZone);
                     }
                 }
+                 buf.readUnsignedShort(); // Skip reserved / software version (2 bytes)
             }
 
             if (deviceSession != null) {
-                sendResponse(channel, false, type, buf.getShort(buf.writerIndex() - 6), null);
+                // Send response for login
+                if (length >= 5) { // Ensure length is valid for reading serial
+                    try {
+                        // Use packet length relative index for serial number
+                        sendResponse(channel, false, type, buf.getShort(length - 3), null);
+                    } catch (IndexOutOfBoundsException e) {
+                         LOGGER.warn("Failed to get serial number for LOGIN type {} with length {}. Index {} out of bounds for buffer size {}.",
+                                type, length, length - 3, buf.capacity());
+                    }
+                }
             }
 
-            return null;
+            return null; // Login doesn't return a position
 
-        } else if (type == MSG_HEARTBEAT) {
+        } else if (type == MSG_HEARTBEAT) { // Often uses type 0x13, same as MSG_STATUS
 
-            getLastLocation(position, null);
+            getLastLocation(position, null); // Initialize time if needed
 
+            // Status byte decoding (assuming standard heartbeat format)
+            if (buf.readableBytes() >= 1 + minTailSize) { // Check for status byte + tail
                 int status = buf.readUnsignedByte();
                 position.set(Position.KEY_ARMED, BitUtil.check(status, 0));
                 position.set(Position.KEY_IGNITION, BitUtil.check(status, 1));
                 position.set(Position.KEY_CHARGE, BitUtil.check(status, 2));
 
-            if (buf.readableBytes() >= 2 + 6) {
-                position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);
+                // Optional fields (check remaining bytes before reading)
+                // Voltage level (1 byte), GSM signal (1 byte) are common in heartbeats
+                if (buf.readableBytes() >= 1 + minTailSize) {
+                     position.set(Position.KEY_VOLTAGE, buf.readUnsignedByte() * 0.1);
                 }
-            if (buf.readableBytes() >= 1 + 6) {
+                 if (buf.readableBytes() >= 1 + minTailSize) {
                      position.set(Position.KEY_RSSI, buf.readUnsignedByte());
                  }
+            } else {
+                LOGGER.warn("Buffer too short for Heartbeat status byte. Length: {}, Readable: {}", length, buf.readableBytes());
+                buf.readerIndex(buf.writerIndex()); // Consume buffer
+                return null; // Malformed
+            }
 
-            sendResponse(channel, false, type, buf.getShort(buf.writerIndex() - 6), null);
+
+            // Send response for heartbeat
+            if (length >= 5) { // Check length for serial reading
+                 try {
+                    // Use packet length relative index for serial number
+                    sendResponse(channel, false, type, buf.getShort(length - 3), null);
+                 } catch (IndexOutOfBoundsException e) {
+                      LOGGER.warn("Failed to get serial number for HEARTBEAT type {} with length {}. Index {} out of bounds for buffer size {}.",
+                                type, length, length - 3, buf.capacity());
+                 }
+            }
 
             return position;
 
-        } else if (type == MSG_ADDRESS_REQUEST) {
+        } else if (type == MSG_ADDRESS_REQUEST) { // 0x21
 
-            String response = "NA&&NA&&0##";
+            String responseText = "NA&&NA&&0##"; // Standard response format
             ByteBuf content = Unpooled.buffer();
-            content.writeByte(response.length());
-            content.writeInt(0);
-            content.writeBytes(response.getBytes(StandardCharsets.US_ASCII));
-            sendResponse(channel, true, MSG_ADDRESS_RESPONSE, 0, content);
+            content.writeByte(responseText.length()); // Command length
+            content.writeInt(0); // Server flag
+            content.writeBytes(responseText.getBytes(StandardCharsets.US_ASCII));
+            // Send response type 0x21 with content (serial = 0)
+            sendResponse(channel, true, MSG_ADDRESS_REQUEST, (short) 0, content);
 
             return null;
 
-        } else if (type == MSG_TIME_REQUEST) {
+        } else if (type == MSG_TIME_REQUEST) { // 0x8A
 
             Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
-            ByteBuf content = Unpooled.buffer();
+            ByteBuf content = Unpooled.buffer(6); // 6 bytes for time
             content.writeByte(calendar.get(Calendar.YEAR) - 2000);
             content.writeByte(calendar.get(Calendar.MONTH) + 1);
             content.writeByte(calendar.get(Calendar.DAY_OF_MONTH));
             content.writeByte(calendar.get(Calendar.HOUR_OF_DAY));
             content.writeByte(calendar.get(Calendar.MINUTE));
             content.writeByte(calendar.get(Calendar.SECOND));
-            sendResponse(channel, false, MSG_TIME_REQUEST, 0, content);
+            // Send response type 0x8A with time content (serial = 0)
+            sendResponse(channel, false, MSG_TIME_REQUEST, (short) 0, content);
 
             return null;
 
-        } else if (type == MSG_X1_GPS) {
-
-            buf.readUnsignedInt(); // data and alarm
-
-            decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));
-
-            buf.readUnsignedShort(); // terminal info
-
-            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
-
+        } else if (type == MSG_X1_GPS) { // 0x24
+             // Define minimum data size before tail for this type
+             // Data/Alarm(4)+GPS(17)+TermInfo(2)+Odo(4)+Cell(9)+Driver(4)+Batt(2)+Power(2)+PortInfo(4)+InOut(2)+ADC(var)
+             int minDataSize = 4 + 17 + 2 + 4 + 9 + 4 + 2 + 2 + 4 + 2; // Minimum size without ADCs
+
+            if (buf.readableBytes() >= minDataSize + minTailSize) {
+                buf.readUnsignedInt(); // data and alarm info (4 bytes)
+                // Use the correct decodeGps signature
+                decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE)); // Reads ~17 bytes
+                buf.readUnsignedShort(); // terminal info (2 bytes)
+                position.set(Position.KEY_ODOMETER, buf.readUnsignedInt()); // 4 bytes
+                // Cell info (MCC, MNC, LAC, CID) = 2 + 1 + 2 + 4 = 9 bytes
                 position.setNetwork(new Network(CellTower.from(
                         buf.readUnsignedShort(), buf.readUnsignedByte(),
                         buf.readUnsignedShort(), buf.readUnsignedInt())));
-
+                // Driver ID (4 bytes)
                 long driverId = buf.readUnsignedInt();
                 if (driverId > 0) {
                     position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(driverId));
                 }
-
+                // Battery and Power (2 + 2 = 4 bytes)
                 position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);
                 position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
-
-            long portInfo = buf.readUnsignedInt();
-
+                long portInfo = buf.readUnsignedInt(); // 4 bytes (controls ADC reading)
+                // Input/Output status (1 + 1 = 2 bytes)
                 position.set(Position.KEY_INPUT, buf.readUnsignedByte());
                 position.set(Position.KEY_OUTPUT, buf.readUnsignedByte());
-
+                // ADC values (variable number, 2 bytes each)
                 for (int i = 1; i <= BitUtil.between(portInfo, 20, 24); i++) {
+                    // Check readable bytes before reading ADC + tail
+                    if (buf.readableBytes() >= 2 + minTailSize) {
                          position.set(Position.PREFIX_ADC + i, buf.readUnsignedShort() * 0.01);
+                    } else {
+                        LOGGER.warn("Buffer too short for ADC reading in MSG_X1_GPS. Index: {}", i);
+                        break; // Stop reading ADCs if buffer ends
                     }
+                }
+            } else {
+                LOGGER.warn("Buffer too short for MSG_X1_GPS base data. Length: {}, Readable: {}", length, buf.readableBytes());
+                buf.readerIndex(buf.writerIndex()); return null; // Malformed
+            }
+            // Response will be sent by common code later
 
-            return position;
-
-        } else if (type == MSG_X1_PHOTO_INFO) {
-
+        } else if (type == MSG_X1_PHOTO_INFO) { // 0x25? Placeholder type
+            // Define minimum data size: Time(6)+Fix(1)+Lat(4)+Lon(4)+CamId(1)+Src(1)+Fmt(1)+PhotoLen(4)+PicId(4) = 26
+            int minDataSize = 26;
+            if (buf.readableBytes() >= minDataSize + minTailSize) {
                 buf.skipBytes(6); // time
                 buf.readUnsignedByte(); // fix status
                 buf.readUnsignedInt(); // latitude
                 buf.readUnsignedInt(); // longitude
                 buf.readUnsignedByte(); // camera id
                 buf.readUnsignedByte(); // photo source
                 buf.readUnsignedByte(); // picture format
-
-            ByteBuf photo = Unpooled.buffer(buf.readInt());
-            int pictureId = buf.readInt();
-            photos.put(pictureId, photo);
+                int photoLength = buf.readInt(); // Photo data length
+                int pictureId = buf.readInt(); // Picture ID
+                // Check if photo data itself is present before tail
+                if (buf.readableBytes() >= photoLength + minTailSize) {
+                    ByteBuf photo = Unpooled.buffer(photoLength); // Store photo data later if needed
+                    // buf.readBytes(photo); // Read photo data if needed
+                    buf.skipBytes(photoLength); // Skip photo data for now
+                    photos.put(pictureId, photo); // Store empty buffer for now
                     sendPhotoRequest(channel, pictureId);
+                } else {
+                    LOGGER.warn("Buffer too short for photo data content in MSG_X1_PHOTO_INFO.");
+                    // Skip remaining buffer to avoid errors
+                    buf.readerIndex(buf.writerIndex());
+                }
+            } else {
+                 LOGGER.warn("Buffer too short for photo header data in MSG_X1_PHOTO_INFO.");
+                 buf.readerIndex(buf.writerIndex());
+            }
+            return null; // No position data, returns null
 
-            return null;
-
-        } else if (type == MSG_WIFI || type == MSG_WIFI_2 || type == MSG_WIFI_4) {
-
-            ByteBuf time = buf.readSlice(6);
+        } else if (type == MSG_WIFI || type == MSG_WIFI_2 || type == MSG_WIFI_4) { // 0x28, 0x2C, 0xCC
+            // Min Data: Time(6). Specifics depend on type. Check inside.
+            if (buf.readableBytes() >= 6 + minTailSize) {
+                ByteBuf timeSlice = buf.readSlice(6); // Read time (6 BCD bytes)
                 DateBuilder dateBuilder = new DateBuilder()
-                    .setYear(BcdUtil.readInteger(time, 2))
-                    .setMonth(BcdUtil.readInteger(time, 2))
-                    .setDay(BcdUtil.readInteger(time, 2))
-                    .setHour(BcdUtil.readInteger(time, 2))
-                    .setMinute(BcdUtil.readInteger(time, 2))
-                    .setSecond(BcdUtil.readInteger(time, 2));
+                        .setYear(BcdUtil.readInteger(timeSlice, 2))
+                        .setMonth(BcdUtil.readInteger(timeSlice, 2))
+                        .setDay(BcdUtil.readInteger(timeSlice, 2))
+                        .setHour(BcdUtil.readInteger(timeSlice, 2))
+                        .setMinute(BcdUtil.readInteger(timeSlice, 2))
+                        .setSecond(BcdUtil.readInteger(timeSlice, 2));
                 getLastLocation(position, dateBuilder.getDate());
-
                 Network network = new Network();
-
-            int wifiCount;
-            if (type == MSG_WIFI_4) {
+                int wifiCount = 0;
+                if (type == MSG_WIFI_4) { // 0xCC requires Count(1) + AP data + tail
+                    if (buf.readableBytes() >= 1 + minTailSize) {
+                         wifiCount = buf.readUnsignedByte();
+                    } else { LOGGER.warn("Buffer short for Wifi count (Type 0xCC)."); }
+                } else { // 0x28, 0x2C require Cell Info + Wifi Count + AP data + TA + tail
+                    // Peek at Wifi count byte (original logic: getUnsignedByte(readerIndex + 2)) - seems fragile.
+                    // Assuming fixed structure: Time(6)+CellCount(1)+MCC(2)+MNC(1)+Cells+TA(1)+WifiCount(1)+APs+tail
+                    // Let's read based on this assumed structure with checks.
+                    // Try reading cell info first for 0x28/0x2C
+                     int cellCount = 0;
+                     int mcc = 0, mnc = 0;
+                     if (buf.readableBytes() >= 1 + 2 + 1 + minTailSize) { // CellCount+MCC+MNC+tail
+                         cellCount = buf.readUnsignedByte();
+                         mcc = buf.readUnsignedShort();
+                         mnc = buf.readUnsignedByte();
+                         for (int i = 0; i < cellCount; i++) {
+                             // Need LAC(2) + CID(2) + RSSI(1) = 5 bytes per tower
+                             if (buf.readableBytes() >= 5 + minTailSize) { // Check space for cell + tail
+                                 network.addCellTower(CellTower.from(
+                                         mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(), buf.readUnsignedByte()));
+                             } else { LOGGER.warn("Buffer short for Cell Tower {}. Type {}", i, type); break; }
+                         }
+                     } else { LOGGER.warn("Buffer short for Cell header. Type {}", type); }
+                     // Now read TA(1) and WifiCount(1)
+                     if (buf.readableBytes() >= 1 + 1 + minTailSize) {
+                         buf.readUnsignedByte(); // Skip TA
                          wifiCount = buf.readUnsignedByte();
-            } else {
-                wifiCount = buf.getUnsignedByte(2);
+                     } else { LOGGER.warn("Buffer short for TA/WifiCount. Type {}", type); }
                 }
 
+                // Read Wifi APs
                 for (int i = 0; i < wifiCount; i++) {
-                if (type == MSG_WIFI_4) {
-                    buf.skipBytes(2);
-                }
+                     int bytesNeeded = 6; // MAC address
+                     if (type == MSG_WIFI_4) { bytesNeeded += 2; } // Skip 2 bytes
+                     else { bytesNeeded += 1; } // Signal strength
+                    if (buf.readableBytes() >= bytesNeeded + minTailSize) { // Check space for AP + tail
+                         if (type == MSG_WIFI_4) { buf.skipBytes(2); }
                          WifiAccessPoint wifiAccessPoint = new WifiAccessPoint();
                          wifiAccessPoint.setMacAddress(String.format("%02x:%02x:%02x:%02x:%02x:%02x",
                                  buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte(),
                                  buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte()));
                          if (type != MSG_WIFI_4) {
                              wifiAccessPoint.setSignalStrength((int) buf.readUnsignedByte());
                          }
                          network.addWifiAccessPoint(wifiAccessPoint);
+                     } else { LOGGER.warn("Buffer short for WiFi AP {}. Type {}", i, type); break; }
                 }
-
-            if (type != MSG_WIFI_4) {
-
-                int cellCount = buf.readUnsignedByte();
-                int mcc = buf.readUnsignedShort();
-                int mnc = buf.readUnsignedByte();
-                for (int i = 0; i < cellCount; i++) {
-                    network.addCellTower(CellTower.from(
-                            mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(), buf.readUnsignedByte()));
-                }
-
-                if (channel != null) {
-                    ByteBuf response = Unpooled.buffer();
-                    response.writeShort(0x7878);
-                    response.writeByte(0);
-                    response.writeByte(type);
-                    response.writeBytes(time.resetReaderIndex());
-                    response.writeByte('\r');
-                    response.writeByte('\n');
-                    channel.writeAndFlush(new NetworkMessage(response, channel.remoteAddress()));
-                }
-
-            }
+                 // Custom response logic for 0x28/0x2C removed - rely on standard response
 
                 position.setNetwork(network);
+            } else {
+                LOGGER.warn("Buffer too short for WiFi base data (Time). Type {}", type);
+                buf.readerIndex(buf.writerIndex()); return null; // Malformed
+            }
+            // Response will be sent by common code later
 
-            return position;
-
-        } else if (type == MSG_INFO) {
-
+        } else if (type == MSG_INFO) { // 0x94
+            // Structure assumed: Power(2) + tail
              getLastLocation(position, null);
-
+             if (buf.readableBytes() >= 2 + minTailSize) {
                  position.set(Position.KEY_POWER, buf.readShort() * 0.01);
+             } else {
+                 LOGGER.warn("Buffer too short for Power in MSG_INFO.");
+                 // Don't bail out, partial info might be acceptable
+             }
+            // Response will be sent by common code later
 
-            return position;
-
-        } else if (type == MSG_LBS_MULTIPLE_3 && variant == Variant.SR411_MINI) {
-
+        } else if (type == MSG_LBS_MULTIPLE_3 && variant == Variant.SR411_MINI) { // 0xA3 variant
+             // Structure: GPS + LBS + Ignition(1) + Power(2) + Battery(2) + tail
+             // Estimate GPS(~17) + LBS(~9) + Trailer(5) = 31 bytes minimum data
+             int minDataSize = 31;
+            if (buf.readableBytes() >= minDataSize + minTailSize) {
                 decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));
-
-            decodeLbs(position, buf, type, false);
-
+                decodeLbs(position, buf, type, false); // LBS data
+                // Read trailer fields
                 position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);
                 position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
                 position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);
-
-            return position;
-
-        } else if (type == MSG_LBS_MULTIPLE_1 || type == MSG_LBS_MULTIPLE_2 || type == MSG_LBS_MULTIPLE_3
-                || type == MSG_LBS_EXTEND || type == MSG_LBS_WIFI || type == MSG_LBS_2
-                || type == MSG_WIFI_3 || type == MSG_WIFI_5) {
-
-            boolean longFormat = type == MSG_LBS_2 || type == MSG_WIFI_3 || type == MSG_WIFI_5;
-
+            } else {
+                 LOGGER.warn("Buffer too short for MSG_LBS_MULTIPLE_3 (SR411_MINI) data.");
+                 buf.readerIndex(buf.writerIndex()); return null; // Malformed
+            }
+            // Response will be sent by common code later
+
+        } else if (type == MSG_LBS_MULTIPLE_1 || type == MSG_LBS_MULTIPLE_2 || type == MSG_LBS_MULTIPLE_3 // 0xA1,A2,A3
+                || type == MSG_LBS_EXTEND || type == MSG_LBS_WIFI || type == MSG_LBS_2 // A4, A5, AA
+                || type == MSG_WIFI_3 || type == MSG_WIFI_5) { // AF, B0
+            // Structure: Time(6) + [TA(1)?] + CellHeader(3/4) + Cells(var) + [TA(1)?] + [Wifi(var)?] + tail
+            int minDataSize = 6 + 3; // Time + MCC/MNC minimum
+            if (buf.readableBytes() >= minDataSize + minTailSize) {
+                boolean longFormat = type == MSG_LBS_2 || type == MSG_WIFI_3 || type == MSG_WIFI_5; // AA, AF, B0
                 DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))
                         .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())
                         .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());
-
                 getLastLocation(position, dateBuilder.getDate());
-
-            if (variant == Variant.WANWAY_S20) {
-                buf.readUnsignedByte(); // ta
-            }
-
+                if (variant == Variant.WANWAY_S20) { buf.readUnsignedByte(); } // ta
                 int mcc = buf.readUnsignedShort();
-            int mnc = BitUtil.check(mcc, 15) ? buf.readUnsignedShort() : buf.readUnsignedByte();
+                int mncBytes = BitUtil.check(mcc, 15) ? 2 : 1;
+                int mnc = mncBytes == 2 ? buf.readUnsignedShort() : buf.readUnsignedByte();
                 Network network = new Network();
+                int cellCount = 0;
+                if (buf.readableBytes() >= 1 + minTailSize) { // Check for cell count byte
+                     cellCount = variant == Variant.WANWAY_S20 ? buf.readUnsignedByte() : (type == MSG_WIFI_5 ? 6 : 7);
+                } else { LOGGER.warn("Buffer short for cell count byte. Type {}", type); }
 
-            int cellCount = variant == Variant.WANWAY_S20 ? buf.readUnsignedByte() : type == MSG_WIFI_5 ? 6 : 7;
                 for (int i = 0; i < cellCount; i++) {
+                     int lacBytes = longFormat ? 4 : 2;
+                     int cidBytes = longFormat ? 8 : 3;
+                     int bytesNeeded = lacBytes + cidBytes + 1; // + RSSI(1)
+                    if (buf.readableBytes() >= bytesNeeded + minTailSize) { // Check space for cell + tail
                          int lac = longFormat ? buf.readInt() : buf.readUnsignedShort();
                          int cid = longFormat ? (int) buf.readLong() : buf.readUnsignedMedium();
                          int rssi = -buf.readUnsignedByte();
-                if (lac > 0) {
+                         if (lac > 0 && cid > 0) {
                              network.addCellTower(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid, rssi));
                          }
+                     } else { LOGGER.warn("Buffer short for LBS Cell {}. Type {}", i, type); break; }
                 }
-
                 if (variant != Variant.WANWAY_S20) {
-                buf.readUnsignedByte(); // ta
+                     if (buf.readableBytes() >= 1 + minTailSize) { buf.readUnsignedByte(); } // ta
+                     else { LOGGER.warn("Buffer short for TA byte. Type {}", type); }
                 }
-
-            if (type != MSG_LBS_MULTIPLE_1 && type != MSG_LBS_MULTIPLE_2 && type != MSG_LBS_MULTIPLE_3
-                    && type != MSG_LBS_2) {
+                if (type != MSG_LBS_MULTIPLE_1 && type != MSG_LBS_MULTIPLE_2 && type != MSG_LBS_MULTIPLE_3 && type != MSG_LBS_2) {
+                    if (buf.readableBytes() >= 1 + minTailSize) { // Check for wifi count
                          int wifiCount = buf.readUnsignedByte();
                          for (int i = 0; i < wifiCount; i++) {
+                             if (buf.readableBytes() >= 7 + minTailSize) { // MAC(6) + RSSI(1) + tail
                                  String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll("(..)", "$1:");
                                  network.addWifiAccessPoint(WifiAccessPoint.from(
                                          mac.substring(0, mac.length() - 1), buf.readUnsignedByte()));
+                             } else { LOGGER.warn("Buffer short for LBS WiFi AP {}. Type {}", i, type); break; }
                          }
+                     } else { LOGGER.warn("Buffer short for WiFi count. Type {}", type); }
                 }
-
                 position.setNetwork(network);
+            } else {
+                LOGGER.warn("Buffer too short for LBS base data. Type {}", type);
+                buf.readerIndex(buf.writerIndex()); return null; // Malformed
+            }
+            // Response will be sent by common code later
 
-        } else if (type == MSG_STRING) {
-
+        } else if (type == MSG_STRING) { // 0x15
+            // Structure: CmdLen(1) + [Flag(4)+String(CmdLen-4)] + tail
             getLastLocation(position, null);
-
+             if (buf.readableBytes() >= 1 + minTailSize) { // Check for CmdLen + tail
                  int commandLength = buf.readUnsignedByte();
-
                  if (commandLength > 0) {
-                buf.readUnsignedInt(); // server flag (reserved)
-                String data = buf.readSlice(commandLength - 4).toString(StandardCharsets.US_ASCII);
-                if (data.startsWith("<ICCID:")) {
+                     int dataBytesNeeded = commandLength; // Flag(4) + String(CmdLen-4) = CmdLen
+                     if (buf.readableBytes() >= dataBytesNeeded + minTailSize) {
+                         buf.readUnsignedInt(); // server flag (reserved, 4 bytes)
+                         int stringDataLength = commandLength - 4;
+                         if (stringDataLength > 0) {
+                             String data = buf.readSlice(stringDataLength).toString(StandardCharsets.US_ASCII);
+                             if (data.startsWith("<ICCID:") && data.length() >= 27) {
                                  position.set(Position.KEY_ICCID, data.substring(7, 27));
                              } else {
                                  position.set(Position.KEY_RESULT, data);
                              }
-            }
-
-        } else if (type == MSG_BMS) {
-
-            buf.skipBytes(8); // serial number
-
-            getLastLocation(position, new Date(buf.readUnsignedInt() * 1000));
-
+                         } else if (stringDataLength < 0) { LOGGER.warn("Invalid commandLength {} in MSG_STRING.", commandLength); }
+                     } else { LOGGER.warn("Buffer short for command data {}. CmdLen={}, Type {}", commandLength, type); }
+                 } // else: commandLength is 0, nothing to read
+             } else { LOGGER.warn("Buffer short for commandLength byte. Type {}", type); }
+            // Response will be sent by common code later
+
+        } else if (type == MSG_BMS) { // 0xB9
+            // Structure: DevSerial(8)+Timestamp(4)+BMSData(85)+tail
+            int minDataSize = 8 + 4 + 85;
+            if (buf.readableBytes() >= minDataSize + minTailSize) {
+                buf.skipBytes(8); // device serial number
+                getLastLocation(position, new Date(buf.readUnsignedInt() * 1000)); // timestamp
                 position.set("relativeCapacity", buf.readUnsignedByte());
                 position.set("remainingCapacity", buf.readUnsignedShort());
                 position.set("absoluteCapacity", buf.readUnsignedByte());
                 position.set("fullCapacity", buf.readUnsignedShort());
                 position.set("batteryHealth", buf.readUnsignedByte());
                 position.set("batteryTemp", buf.readUnsignedShort() * 0.1 - 273.1);
                 position.set("current", buf.readUnsignedShort());
-            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);
+                position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001); // Voltage
                 position.set("cycleIndex", buf.readUnsignedShort());
                 for (int i = 1; i <= 14; i++) {
                     position.set("batteryCell" + i, buf.readUnsignedShort() * 0.001);
                 }
                 position.set("currentChargeInterval", buf.readUnsignedShort());
                 position.set("maxChargeInterval", buf.readUnsignedShort());
                 position.set("barcode", buf.readCharSequence(16, StandardCharsets.US_ASCII).toString().trim());
                 position.set("batteryVersion", buf.readUnsignedShort());
                 position.set("manufacturer", buf.readCharSequence(16, StandardCharsets.US_ASCII).toString().trim());
-            position.set("batteryStatus", buf.readUnsignedInt());
-
+                position.set("batteryStatus", buf.readUnsignedInt()); // BMS status
                 position.set("controllerStatus", buf.readUnsignedInt());
                 position.set("controllerFault", buf.readUnsignedInt());
 
-            sendResponse(channel, false, type, buf.getShort(buf.writerIndex() - 6), null);
-
-            return position;
-
-        } else if (type == MSG_STATUS && buf.readableBytes() == 22) {
+                // Send response for BMS
+                 if (length >= 5) { // Check length for serial reading
+                     try {
+                         // Use packet length relative index for serial number
+                         sendResponse(channel, false, type, buf.getShort(length - 3), null);
+                     } catch (IndexOutOfBoundsException e) {
+                         LOGGER.warn("Failed to get serial number for BMS type {} with length {}. Index {} out of bounds for buffer size {}.",
+                                 type, length, length - 3, buf.capacity());
+                     }
+                 }
+            } else {
+                 LOGGER.warn("Buffer too short for BMS data. Readable: {}, Required: ~{}", buf.readableBytes(), minDataSize + minTailSize);
+                 buf.readerIndex(buf.writerIndex()); // Consume buffer
+            }
+            return position; // Return position even if buffer was short? Or null? Returning position.
 
+        } else if (type == MSG_STATUS && buf.readableBytes() >= 22 + minTailSize) { // 0x13 specific length check
+             // Structure: Info(1)+Sat(2)+Alarm(1)+LangRaw(1)+BattLvl(1)+Mode(1)+Volt(2)+Res(1)+Times(2)+Time(2)+Temp(2) = 18 bytes data? No, 22 bytes total payload.
             getLastLocation(position, null);
-
             buf.readUnsignedByte(); // information content
-            buf.readUnsignedShort(); // satellites
-            buf.readUnsignedByte(); // alarm
-            buf.readUnsignedByte(); // language
-
-            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
-
+            buf.readUnsignedShort(); // satellites (raw format)
+            buf.readUnsignedByte(); // alarm (raw)
+            buf.readUnsignedByte(); // language (raw)
+            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); // Raw battery level
             buf.readUnsignedByte(); // working mode
-            buf.readUnsignedShort(); // working voltage
+            buf.readUnsignedShort(); // working voltage (raw)
             buf.readUnsignedByte(); // reserved
-            buf.readUnsignedShort(); // working times
-            buf.readUnsignedShort(); // working time
-
-            int value = buf.readUnsignedShort();
+            buf.readUnsignedShort(); // working times (count?)
+            buf.readUnsignedShort(); // working time (duration?)
+            int value = buf.readUnsignedShort(); // Temperature raw value
             double temperature = BitUtil.to(value, 15) * 0.1;
-            position.set(Position.PREFIX_TEMP + 1, BitUtil.check(value, 15) ? temperature : -temperature);
+            position.set(Position.PREFIX_TEMP + 1, BitUtil.check(value, 15) ? temperature : -temperature); // Signed temp
+            // Ensure exactly 22 bytes were consumed before tail
+             int bytesToSkip = 22 - (1 + 2 + 1 + 1 + 1 + 1 + 2 + 1 + 2 + 2 + 2); // Should be 0 if structure is correct
+             if (bytesToSkip > 0 && buf.readableBytes() >= bytesToSkip + minTailSize) {
+                 buf.skipBytes(bytesToSkip);
+             } else if (bytesToSkip < 0) { LOGGER.warn("Read too many bytes for MSG_STATUS fixed length."); }
+             else if (buf.readableBytes() < minTailSize) { LOGGER.warn("Buffer short after MSG_STATUS fixed length data."); }
+            // Response will be sent by common code later
 
-        } else if (isSupported(type)) {
+        } else if (isSupported(type)) { // Generic handling for GPS/LBS/Status types
 
-            if (type == MSG_LBS_STATUS && variant == Variant.SPACE10X) {
-                return null; // multi-lbs message
+            if (type == MSG_LBS_STATUS && variant == Variant.SPACE10X) { // 0xAB variant
+                 buf.readerIndex(buf.writerIndex()); return null; // Skip multi-lbs message
             }
 
             if (hasGps(type)) {
+                 // GPS data size: Time(6)+Lat(4)+Lon(4)+Speed(1)+Status/Course(2)=17
+                 if (buf.readableBytes() >= 17 + minTailSize) {
                      decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));
+                 } else { LOGGER.warn("Buffer short for GPS data. Type {}", type); buf.readerIndex(buf.writerIndex()); return null; }
             } else {
-                getLastLocation(position, null);
+                getLastLocation(position, null); // Initialize time if no GPS
             }
 
             if (hasLbs(type)) {
+                 // LBS size varies greatly, decodeLbs must handle bounds checks internally
                  decodeLbs(position, buf, type, hasStatus(type) && type != MSG_LBS_ALARM);
             }
 
             if (hasStatus(type)) {
-                decodeStatus(position, buf);
-                if (variant == Variant.OBD6) {
+                 // Base Status: TermInfo(1)+Voltage(1)+GSM(1)=3
+                 if (buf.readableBytes() >= 3 + minTailSize) {
+                     decodeStatus(position, buf); // Reads 3 bytes
+                     if (variant == Variant.OBD6) { // OBD6 adds 8 bytes
+                         if (buf.readableBytes() >= 8 + minTailSize) {
                              int signal = buf.readUnsignedShort();
-                    int satellites = BitUtil.between(signal, 10, 15) + BitUtil.between(signal, 5, 10);
-                    position.set(Position.KEY_SATELLITES, satellites);
+                             position.set(Position.KEY_SATELLITES, BitUtil.between(signal, 10, 15) + BitUtil.between(signal, 5, 10));
                              position.set(Position.KEY_RSSI, BitUtil.to(signal, 5));
                              position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));
-                    buf.readUnsignedByte(); // language
+                             buf.readUnsignedByte(); // language raw
                              position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
                              buf.readUnsignedByte(); // working mode
                              position.set(Position.KEY_POWER, buf.readUnsignedShort() / 100.0);
-                } else {
-                    position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 100 / 6);
+                         } else { LOGGER.warn("Buffer short for OBD6 status ext. Type {}", type); }
+                     } else { // Standard status adds 3 bytes
+                         if (buf.readableBytes() >= 3 + minTailSize) {
+                             position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 100 / 6); // Specific formula
                              position.set(Position.KEY_RSSI, buf.readUnsignedByte());
                              position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));
+                         } else { LOGGER.warn("Buffer short for standard status ext. Type {}", type); }
                      }
+                 } else { LOGGER.warn("Buffer short for base Status data. Type {}", type); }
             }
 
-            if (type == MSG_GPS_LBS_1) {
-                if (variant == Variant.GT06E_CARD) {
+            // Type-specific extensions after common parts
+            if (type == MSG_GPS_LBS_1) { // 0x12
+                if (variant == Variant.GT06E_CARD) { // Odo(4)+Len(1)+Data(var)+Alarm(1)+Swiped(1)+tail
+                    if (buf.readableBytes() >= 4 + 1 + minTailSize) {
                          position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
-                    String data = buf.readCharSequence(buf.readUnsignedByte(), StandardCharsets.US_ASCII).toString();
-                    buf.readUnsignedByte(); // alarm
-                    buf.readUnsignedByte(); // swiped
+                         int dataLen = buf.readUnsignedByte();
+                         if (buf.readableBytes() >= dataLen + 1 + 1 + minTailSize) {
+                             String data = buf.readCharSequence(dataLen, StandardCharsets.US_ASCII).toString();
+                             buf.readUnsignedByte(); // alarm raw
+                             buf.readUnsignedByte(); // swiped status
                              position.set("driverLicense", data.trim());
-                } else if (variant == Variant.BENWAY) {
+                         } else { LOGGER.warn("Buffer short for GT06E CardLicence data."); }
+                    } else { LOGGER.warn("Buffer short for GT06E Odometer/DataLen."); }
+                } else if (variant == Variant.BENWAY) { // Mask(2)+tail
+                    if (buf.readableBytes() >= 2 + minTailSize) {
                          int mask = buf.readUnsignedShort();
                          position.set(Position.KEY_IGNITION, BitUtil.check(mask, 8 + 7));
                          position.set(Position.PREFIX_IN + 2, BitUtil.check(mask, 8 + 6));
-                    if (BitUtil.check(mask, 8 + 4)) {
-                        int value = BitUtil.to(mask, 8 + 1);
-                        if (BitUtil.check(mask, 8 + 1)) {
-                            value = -value;
-                        }
+                         if (BitUtil.check(mask, 8 + 4)) { // Temp reading
+                             int value = BitUtil.to(mask, 4); // Assuming 4 bits for temp value? Check spec.
+                             if (BitUtil.check(mask, 8 + 1)) { value = -value; } // Assuming bit 9 is sign? Check spec.
                              position.set(Position.PREFIX_TEMP + 1, value);
-                    } else {
-                        int value = BitUtil.to(mask, 8 + 2);
-                        if (BitUtil.check(mask, 8 + 5)) {
+                         } else { // ADC reading
+                             int value = BitUtil.to(mask, 5); // Assuming 5 bits for ADC value? Check spec.
+                             if (BitUtil.check(mask, 8 + 5)) { // Flag for raw ADC?
                                  position.set(Position.PREFIX_ADC + 1, value);
-                        } else {
+                             } else { // Flag for scaled ADC?
                                  position.set(Position.PREFIX_ADC + 1, value * 0.1);
                              }
                          }
-                } else if (variant == Variant.VXT01) {
-                    decodeStatus(position, buf);
+                    } else { LOGGER.warn("Buffer short for BENWAY mask."); }
+                } else if (variant == Variant.VXT01) { // Status(3)+Power(2)+RSSI(1)+AlarmExt(1)+tail
+                    if (buf.readableBytes() >= 3 + 2 + 1 + 1 + minTailSize) {
+                         decodeStatus(position, buf); // Reads 3 bytes if not already done? Redundant?
                          position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
                          position.set(Position.KEY_RSSI, buf.readUnsignedByte());
-                    buf.readUnsignedByte(); // alarm extension
-                } else if (variant == Variant.S5) {
-                    decodeStatus(position, buf);
+                         buf.readUnsignedByte(); // alarm extension raw
+                    } else { LOGGER.warn("Buffer short for VXT01 extension."); }
+                } else if (variant == Variant.S5) { // Status(3)+Power(2)+RSSI(1)+Alarm(1)+Oil(2)+Temp(1)+Odo(4)+tail
+                     if (buf.readableBytes() >= 3 + 2 + 1 + 1 + 2 + 1 + 4 + minTailSize) {
+                         decodeStatus(position, buf); // Redundant?
                          position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
                          position.set(Position.KEY_RSSI, buf.readUnsignedByte());
                          position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));
                          position.set("oil", buf.readUnsignedShort());
-                    int temperature = buf.readUnsignedByte();
-                    if (BitUtil.check(temperature, 7)) {
-                        temperature = -BitUtil.to(temperature, 7);
-                    }
+                         int temperatureRaw = buf.readUnsignedByte();
+                         int temperature = BitUtil.to(temperatureRaw, 7);
+                         if (BitUtil.check(temperatureRaw, 7)) { temperature = -temperature; }
                          position.set(Position.PREFIX_TEMP + 1, temperature);
-                    position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 10);
+                         position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 10); // Scaling * 10
+                     } else { LOGGER.warn("Buffer short for S5 extension."); }
                 }
             }
 
-            if ((type == MSG_GPS_LBS_2 || type == MSG_GPS_LBS_3 || type == MSG_GPS_LBS_4)
-                    && buf.readableBytes() >= 3 + 6) {
+            if ((type == MSG_GPS_LBS_2 || type == MSG_GPS_LBS_3 || type == MSG_GPS_LBS_4) // A8, B1, B2
+                    && buf.readableBytes() >= 3 + minTailSize) { // Ignition(1)+Event(1)+Archive(1)+tail
                 position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);
-                position.set(Position.KEY_EVENT, buf.readUnsignedByte()); // reason
+                position.set(Position.KEY_EVENT, buf.readUnsignedByte()); // reason code raw
                 position.set(Position.KEY_ARCHIVE, buf.readUnsignedByte() > 0);
             }
 
-            if (type == MSG_GPS_LBS_3) {
+            if (type == MSG_GPS_LBS_3 && buf.readableBytes() >= 3 + minTailSize) { // B1 module: ID(2)+Len(1)+Data(var)+tail
                  int module = buf.readUnsignedShort();
                  int subLength = buf.readUnsignedByte();
+                 if (buf.readableBytes() >= subLength + minTailSize) {
                      switch (module) {
-                    case 0x0027:
-                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
-                        break;
-                    case 0x002E:
-                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
-                        break;
-                    case 0x003B:
-                        position.setAccuracy(buf.readUnsignedShort() * 0.01);
-                        break;
-                    default:
-                        buf.skipBytes(subLength);
-                        break;
+                         case 0x0027: if (subLength == 2) position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01); else buf.skipBytes(subLength); break;
+                         case 0x002E: if (subLength == 4) position.set(Position.KEY_ODOMETER, buf.readUnsignedInt()); else buf.skipBytes(subLength); break;
+                         case 0x003B: if (subLength == 2) position.setAccuracy(buf.readUnsignedShort() * 0.01); else buf.skipBytes(subLength); break;
+                         default: buf.skipBytes(subLength); break;
                      }
+                 } else { LOGGER.warn("Buffer short for GPS_LBS_3 module data. Module {}, SubLen {}", module, subLength); }
             }
+            // Removed general odometer check: if (buf.readableBytes() == 4 + 6)
 
-            if (buf.readableBytes() == 4 + 6) {
-                position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
-            }
-
-        } else if (type == MSG_ALARM) {
-
-            boolean extendedAlarm = dataLength > 7;
-            if (extendedAlarm) {
-                decodeGps(position, buf, false, false, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));
-            } else {
+        } else if (type == MSG_ALARM) { // 0x16
+             // Base=1(type)+1(alarm)+Tail(6)=8. Time=6. GPS=18.
+             boolean extendedAlarm = length > 14; // Length includes Type(1)+Data+Tail(6)
+             if (extendedAlarm) { // GPS + Alarm Type + Tail
+                 if (buf.readableBytes() >= 18 + 1 + minTailSize) { // GPS(18)+AlarmType(1)+tail
+                     decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));
+                 } else { LOGGER.warn("Buffer short for extended Alarm GPS."); buf.readerIndex(buf.writerIndex()); return null; }
+             } else { // Time + Alarm Type + Tail
+                 if (buf.readableBytes() >= 6 + 1 + minTailSize) { // Time(6)+AlarmType(1)+tail
                      DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))
                              .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())
                              .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());
                      getLastLocation(position, dateBuilder.getDate());
+                 } else { LOGGER.warn("Buffer short for non-extended Alarm time."); buf.readerIndex(buf.writerIndex()); return null; }
              }
-            short alarmType = buf.readUnsignedByte();
-            switch (alarmType) {
-                case 0x01:
-                    position.set(Position.KEY_ALARM, extendedAlarm ? Position.ALARM_SOS : Position.ALARM_GENERAL);
-                    break;
-                case 0x80:
-                    position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);
-                    break;
-                case 0x87:
-                    position.set(Position.KEY_ALARM, Position.ALARM_OVERSPEED);
-                    break;
-                case 0x90:
-                    position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION);
-                    break;
-                case 0x91:
-                    position.set(Position.KEY_ALARM, Position.ALARM_BRAKING);
-                    break;
-                case 0x92:
-                    position.set(Position.KEY_ALARM, Position.ALARM_CORNERING);
-                    break;
-                case 0x93:
-                    position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT);
-                    break;
-                default:
-                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);
-                    break;
+             // Read Alarm Type (1 byte)
+             if (buf.readableBytes() >= 1 + minTailSize) {
+                 short alarmCode = buf.readUnsignedByte();
+                 switch (alarmCode) {
+                     case 0x01: position.set(Position.KEY_ALARM, extendedAlarm ? Position.ALARM_SOS : Position.ALARM_GENERAL); break;
+                     case 0x80: position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION); break;
+                     case 0x87: position.set(Position.KEY_ALARM, Position.ALARM_OVERSPEED); break;
+                     case 0x90: position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION); break;
+                     case 0x91: position.set(Position.KEY_ALARM, Position.ALARM_BRAKING); break;
+                     case 0x92: position.set(Position.KEY_ALARM, Position.ALARM_CORNERING); break;
+                     case 0x93: position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT); break;
+                     default:   position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;
                  }
+             } else { LOGGER.warn("Buffer short for Alarm type code."); buf.readerIndex(buf.writerIndex()); return null; }
 
-        } else {
+        } else { // Unknown message type
 
-            if (dataLength > 0) {
-                buf.skipBytes(dataLength);
-            }
             if (type != MSG_COMMAND_0 && type != MSG_COMMAND_1 && type != MSG_COMMAND_2) {
-                sendResponse(channel, false, type, buf.getShort(buf.writerIndex() - 6), null);
+                if (length >= 5) { // Check if length allows for Type+Serial+CRC
+                    try {
+                        // Attempt to read serial using packet length relative index
+                        short serial = buf.getShort(length - 3);
+                        sendResponse(channel, false, type, serial, null);
+                    } catch (IndexOutOfBoundsException e) {
+                         LOGGER.warn("Failed to get serial for unknown type {} len {}. Index {} OOB for capacity {}.",
+                                type, length, length - 3, buf.capacity());
                     }
+                } else {
+                     LOGGER.warn("Invalid length {} for unknown type {}, cannot send response", length, type);
+                }
+            }
+             // Consume remaining bytes of the buffer for unknown type
+             buf.readerIndex(buf.writerIndex());
             return null;
+        }
 
-        }
+        // Common tail processing (Language, Geofence) for types that fall through
 
         if (hasLanguage(type)) {
-            buf.readUnsignedShort();
+             // Check if enough bytes remain for Lang(2) + Serial(2) + CRC(2) = 6
+             if (buf.readableBytes() >= 6) {
+                 buf.readUnsignedShort(); // Read Language field
+             } else {
+                 // Avoid reading if buffer is short, but log it. Data might be truncated/malformed.
+                 LOGGER.warn("Buffer too short for language field. Type: {}, Length: {}, Readable: {}", type, length, buf.readableBytes());
+                 // Don't return null here, maybe partial data is still useful.
+             }
         }
 
-        if (type == MSG_GPS_LBS_STATUS_3 || type == MSG_FENCE_MULTI) {
+        if (type == MSG_GPS_LBS_STATUS_3 || type == MSG_FENCE_MULTI) { // A9, AA check Geofence byte
+             // Check if enough bytes remain for Geofence(1) + Serial(2) + CRC(2) = 5
+             if (buf.readableBytes() >= 5) {
                  position.set(Position.KEY_GEOFENCE, buf.readUnsignedByte());
+             } else {
+                 LOGGER.warn("Buffer too short for geofence field. Type: {}, Length: {}, Readable: {}", type, length, buf.readableBytes());
              }
+        }
+
+        // Final common response send (only if not already sent, e.g., by Login, Heartbeat, BMS)
+        // Check if response should be sent based on type
+        boolean responseSent = (type == MSG_LOGIN || type == MSG_HEARTBEAT || type == MSG_BMS ||
+                                type == MSG_ADDRESS_REQUEST || type == MSG_TIME_REQUEST);
 
-        sendResponse(channel, false, type, buf.getShort(buf.writerIndex() - 6), null);
+        if (!responseSent) {
+            if (length >= 5) { // Ensure length allows for serial+crc
+                 // Check if buffer has enough readable bytes for serial+crc (4 bytes)
+                 if (buf.readableBytes() >= 4) {
+                     try {
+                         // Use packet length relative index for serial number
+                         sendResponse(channel, false, type, buf.getShort(length - 3), null);
+                     } catch (IndexOutOfBoundsException e) {
+                         LOGGER.warn("Failed to get serial at common point for type {} len {}. Index {} OOB for readable {}.",
+                                 type, length, length - 3, buf.readableBytes(), e);
+                     }
+                 } else {
+                      LOGGER.warn("Buffer short for Serial/CRC at common point. Type {}, Len {}, Readable {}", type, length, buf.readableBytes());
+                 }
+            } else {
+                 LOGGER.warn("Invalid length {} for type {}, cannot send response at common point", length, type);
+            }
+        }
 
         return position;
     }
\ No newline at end of file
