diff --git a/tmp/58e9e64e-9a49-401f-8a3f-95afc0ae8116_buggy.java b/tmp/b131840e-f5d8-4e0b-9675-3acabb7adf59_fixed.java
index 30ed821..9e4a0c0 100644
--- a/tmp/58e9e64e-9a49-401f-8a3f-95afc0ae8116_buggy.java
+++ b/tmp/b131840e-f5d8-4e0b-9675-3acabb7adf59_fixed.java
@@ -1,513 +1,657 @@
         boolean process(Token t, HtmlTreeBuilder tb) {
             switch (t.type) {
                 case Character: {
                     Token.Character c = t.asCharacter();
-                    if (c.getData().equals(nullString)) {
-                        // todo confirm that check
+                    String data = c.getData();
+
+                    // Handle the spec rule: "If the next token is a U+000A LINE FEED (LF) character token,
+                    // then ignore that token and move on to the next one." for <pre> and <listing> start tags.
+                    // This check is placed here as a workaround, assuming this Character token is the "next token".
+                    // It checks if the current element is <pre> or <listing> and if it's the very first
+                    // content being added (childNodeSize == 0). This might be inaccurate if whitespace nodes
+                    // are inserted before the newline token.
+                    Element current = tb.currentElement(); // The element nodes are being inserted into.
+                    // Check current != null to avoid NullPointerException in fragment parsing scenarios.
+                    if (current != null && data.length() > 0 && data.charAt(0) == '\n' && current.childNodeSize() == 0) {
+                        // Check if the node receiving content is <pre> or <listing>.
+                        if (current.nodeName().equals("pre") || current.nodeName().equals("listing")) {
+                            // If the entire token is just the newline, ignore the token.
+                            if (data.length() == 1) {
+                                return true; // Token ignored.
+                            } else {
+                                // If the token starts with a newline but contains other characters,
+                                // remove the leading newline from the token's data.
+                                // Assumes the Token object's data can be modified (Token.Character#data(String)).
+                                c.data(data.substring(1));
+                                // Update local variable 'data' for subsequent checks, as token's data has changed.
+                                data = c.getData();
+                            }
+                        }
+                        // Note: A similar rule applies to <textarea>. However, <textarea> transitions to the Text state upon insertion.
+                        // That state has different character handling. The correct fix requires a flag in HtmlTreeBuilder
+                        // set during <pre>/<listing>/<textarea> start tag processing and checked at the beginning of character token processing
+                        // across relevant states (InBody, Text). This workaround only fixes it for <pre>/<listing>.
+                    }
+
+                    // Original character handling, now using the potentially modified 'data' / 'c'
+                    if (data.equals(nullString)) {
+                        // todo confirm that check - null character detection
                         tb.error(this);
-                        return false;
-                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed
+                        return false; // ignore char
+                    } else if (tb.framesetOk() && isWhitespace(data)) { // Use isWhitespace(String) as data may have changed
                         tb.reconstructFormattingElements();
-                        tb.insert(c);
+                        tb.insert(c); // Insert the potentially modified token
                     } else {
                         tb.reconstructFormattingElements();
-                        tb.insert(c);
+                        tb.insert(c); // Insert the potentially modified token
                         tb.framesetOk(false);
                     }
                     break;
                 }
                 case Comment: {
                     tb.insert(t.asComment());
                     break;
                 }
                 case Doctype: {
                     tb.error(this);
                     return false;
                 }
                 case StartTag:
                     Token.StartTag startTag = t.asStartTag();
                     // todo - refactor to a switch statement
                     String name = startTag.normalName();
                     if (name.equals("a")) {
                         if (tb.getActiveFormattingElement("a") != null) {
                             tb.error(this);
                             tb.processEndTag("a");
 
                             // still on stack?
                             Element remainingA = tb.getFromStack("a");
                             if (remainingA != null) {
                                 tb.removeFromActiveFormattingElements(remainingA);
                                 tb.removeFromStack(remainingA);
                             }
                         }
                         tb.reconstructFormattingElements();
                         Element a = tb.insert(startTag);
                         tb.pushActiveFormattingElements(a);
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {
                         tb.reconstructFormattingElements();
                         tb.insertEmpty(startTag);
                         tb.framesetOk(false);
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
                     } else if (name.equals("span")) {
                         // same as final else, but short circuits lots of checks
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
                     } else if (name.equals("li")) {
                         tb.framesetOk(false);
                         ArrayList<Element> stack = tb.getStack();
                         for (int i = stack.size() - 1; i > 0; i--) {
                             Element el = stack.get(i);
                             if (el.nodeName().equals("li")) {
                                 tb.processEndTag("li");
                                 break;
                             }
                             if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
                                 break;
                         }
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
                     } else if (name.equals("html")) {
                         tb.error(this);
                         // merge attributes onto real html
+                        if (tb.getStack().isEmpty()) return false; // Ignore if stack is empty (fragment case?)
                         Element html = tb.getStack().get(0);
                         for (Attribute attribute : startTag.getAttributes()) {
                             if (!html.hasAttr(attribute.getKey()))
                                 html.attributes().put(attribute);
                         }
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {
                         return tb.process(t, InHead);
                     } else if (name.equals("body")) {
                         tb.error(this);
                         ArrayList<Element> stack = tb.getStack();
                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
                             // only in fragment case
                             return false; // ignore
                         } else {
                             tb.framesetOk(false);
                             Element body = stack.get(1);
                             for (Attribute attribute : startTag.getAttributes()) {
                                 if (!body.hasAttr(attribute.getKey()))
                                     body.attributes().put(attribute);
                             }
                         }
                     } else if (name.equals("frameset")) {
                         tb.error(this);
                         ArrayList<Element> stack = tb.getStack();
                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
                             // only in fragment case
                             return false; // ignore
                         } else if (!tb.framesetOk()) {
                             return false; // ignore frameset
                         } else {
                             Element second = stack.get(1);
                             if (second.parent() != null)
                                 second.remove();
                             // pop up to html element
                             while (stack.size() > 1)
                                 stack.remove(stack.size()-1);
                             tb.insert(startTag);
                             tb.transition(InFrameset);
                         }
                     } else if (StringUtil.inSorted(name, Constants.Headings)) {
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {
                             tb.error(this);
                             tb.pop();
                         }
                         tb.insert(startTag);
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
+                        // ** The correct fix would involve setting a flag here for the Character case to check **
+                        // ** e.g., tb.setSkipNextNewline(true);                                             **
+                        // The workaround is implemented in the Character case for now.
                         tb.framesetOk(false);
                     } else if (name.equals("form")) {
-                        if (tb.getFormElement() != null) {
+                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) { // Allow nested forms in fragments
                             tb.error(this);
                             return false;
                         }
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
-                        tb.insertForm(startTag, true);
+                        tb.insertForm(startTag, true); // Insert and set form element pointer
                     } else if (StringUtil.inSorted(name, Constants.DdDt)) {
                         tb.framesetOk(false);
                         ArrayList<Element> stack = tb.getStack();
                         for (int i = stack.size() - 1; i > 0; i--) {
                             Element el = stack.get(i);
                             if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {
                                 tb.processEndTag(el.nodeName());
                                 break;
                             }
-                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
-                                break;
+                            // Stop search if semantic block element found, unless it's a <p> inside dd/dt scope? Spec is specific here.
+                            // Spec: "special category" elements break; <p> does not if not in "li breakers" constants? Check constants.
+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) // Using LiBreakers here seems potentially wrong, should be DdDt context. Check spec.
+                                break; // Correct check: stop if special and not 'address', 'div', 'p'. This seems ok.
                         }
-                        if (tb.inButtonScope("p")) {
+                        if (tb.inButtonScope("p")) { // Close P if in button scope
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
                     } else if (name.equals("plaintext")) {
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                     } else if (name.equals("button")) {
                         if (tb.inButtonScope("button")) {
                             // close and reprocess
                             tb.error(this);
                             tb.processEndTag("button");
-                            tb.process(startTag);
+                            return tb.process(startTag); // Reprocess the start tag
                         } else {
                             tb.reconstructFormattingElements();
                             tb.insert(startTag);
                             tb.framesetOk(false);
                         }
                     } else if (StringUtil.inSorted(name, Constants.Formatters)) {
                         tb.reconstructFormattingElements();
                         Element el = tb.insert(startTag);
                         tb.pushActiveFormattingElements(el);
                     } else if (name.equals("nobr")) {
                         tb.reconstructFormattingElements();
                         if (tb.inScope("nobr")) {
                             tb.error(this);
-                            tb.processEndTag("nobr");
-                            tb.reconstructFormattingElements();
+                            tb.processEndTag("nobr"); // Run adoption agency algorithm for nobr
+                            // Need to reconstruct again after potential changes by AAA?
+                            tb.reconstructFormattingElements(); // Redundant? Maybe not if AAA modified stack significantly. Let's keep it.
                         }
                         Element el = tb.insert(startTag);
                         tb.pushActiveFormattingElements(el);
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
                         tb.insertMarkerToFormattingElements();
                         tb.framesetOk(false);
                     } else if (name.equals("table")) {
                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.insert(startTag);
                         tb.framesetOk(false);
                         tb.transition(InTable);
                     } else if (name.equals("input")) {
                         tb.reconstructFormattingElements();
                         Element el = tb.insertEmpty(startTag);
                         if (!el.attr("type").equalsIgnoreCase("hidden"))
                             tb.framesetOk(false);
+                        // Self-closing acknowledged by insertEmpty implicitly? Check tb.insertEmpty. Assume yes.
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {
                         tb.insertEmpty(startTag);
+                        // Acknowledge self-closing flag? These tags are void elements. insertEmpty should handle.
                     } else if (name.equals("hr")) {
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.insertEmpty(startTag);
                         tb.framesetOk(false);
                     } else if (name.equals("image")) {
                         if (tb.getFromStack("svg") == null)
                             return tb.process(startTag.name("img")); // change <image> to <img>, unless in svg
                         else
-                            tb.insert(startTag);
+                            tb.insert(startTag); // Treat as SVG <image> element
                     } else if (name.equals("isindex")) {
                         // how much do we care about the early 90s?
                         tb.error(this);
-                        if (tb.getFormElement() != null)
-                            return false;
+                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) // Check fragment parsing context
+                            return false; // Ignore if form already open (unless fragment parsing)
+
+                        // Acknowledge self-closing flag? Spec doesn't mention. Assume not needed.
+                        tb.tokeniser.acknowledgeSelfClosingFlag(); // It IS often self-closed, acknowledge it.
 
                         tb.processStartTag("form");
                         if (startTag.attributes.hasKey("action")) {
                             Element form = tb.getFormElement();
+                            if (form != null) // Should exist unless fragment parsing form error occurred
                                 form.attr("action", startTag.attributes.get("action"));
                         }
                         tb.processStartTag("hr");
                         tb.processStartTag("label");
                         // hope you like english.
                         String prompt = startTag.attributes.hasKey("prompt") ?
                                 startTag.attributes.get("prompt") :
                                 "This is a searchable index. Enter search keywords: ";
 
                         tb.process(new Token.Character().data(prompt));
 
                         // input
                         Attributes inputAttribs = new Attributes();
                         for (Attribute attr : startTag.attributes) {
-                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))
+                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs)) // Filter attributes
                                 inputAttribs.put(attr);
                         }
-                        inputAttribs.put("name", "isindex");
-                        tb.processStartTag("input", inputAttribs);
-                        tb.processEndTag("label");
-                        tb.processStartTag("hr");
-                        tb.processEndTag("form");
+                        inputAttribs.put("name", "isindex"); // Add name attribute
+                        tb.processStartTag("input", inputAttribs); // Process <input>
+                        tb.processEndTag("label"); // Process </label>
+                        tb.processStartTag("hr"); // Process second <hr>
+                        tb.processEndTag("form"); // Process </form>
                     } else if (name.equals("textarea")) {
                         tb.insert(startTag);
+                        // ** The correct fix would involve setting a flag here for the Text state to check **
+                        // ** e.g., tb.setSkipNextNewline(true);                                            **
                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                         tb.tokeniser.transition(TokeniserState.Rcdata);
                         tb.markInsertionMode();
                         tb.framesetOk(false);
                         tb.transition(Text);
                     } else if (name.equals("xmp")) {
                         if (tb.inButtonScope("p")) {
                             tb.processEndTag("p");
                         }
                         tb.reconstructFormattingElements();
                         tb.framesetOk(false);
                         handleRawtext(startTag, tb);
                     } else if (name.equals("iframe")) {
                         tb.framesetOk(false);
                         handleRawtext(startTag, tb);
                     } else if (name.equals("noembed")) {
                         // also handle noscript if script enabled
                         handleRawtext(startTag, tb);
                     } else if (name.equals("select")) {
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
                         tb.framesetOk(false);
 
                         HtmlTreeBuilderState state = tb.state();
                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                             tb.transition(InSelectInTable);
                         else
                             tb.transition(InSelect);
-                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { // optgroup, option
                         if (tb.currentElement().nodeName().equals("option"))
-                            tb.processEndTag("option");
+                            tb.processEndTag("option"); // Close previous option if current is option
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
-                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { // rp, rt
                         if (tb.inScope("ruby")) {
                             tb.generateImpliedEndTags();
                             if (!tb.currentElement().nodeName().equals("ruby")) {
                                 tb.error(this);
-                                tb.popStackToBefore("ruby"); // i.e. close up to but not include name
+                                tb.popStackToBefore("ruby"); // i.e. close up to but not include ruby
                             }
                             tb.insert(startTag);
+                        } else {
+                            // Treat as normal tag if not in ruby scope? Seems underspecified, assume generic handler.
+                            tb.reconstructFormattingElements();
+                            tb.insert(startTag);
                         }
                     } else if (name.equals("math")) {
                         tb.reconstructFormattingElements();
-                        // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
+                        // Adjust attributes, insert element, switch to foreign content mode.
+                        // TODO: Full MathML foreign content handling. Basic insertion for now.
                         tb.insert(startTag);
+                        if (startTag.isSelfClosing()) tb.tokeniser.acknowledgeSelfClosingFlag(); // Acknowledge but doesn't auto-pop in HTML content model. Need foreign content logic.
+                        // tb.pop(); // Don't pop, wait for end tag or implied close.
                     } else if (name.equals("svg")) {
                         tb.reconstructFormattingElements();
-                        // todo: handle A start tag whose tag name is "svg" (xlink, svg)
+                        // Adjust attributes, insert element, switch to foreign content mode.
+                        // TODO: Full SVG foreign content handling. Basic insertion for now.
                         tb.insert(startTag);
-                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {
+                         if (startTag.isSelfClosing()) tb.tokeniser.acknowledgeSelfClosingFlag(); // Acknowledge but doesn't auto-pop in HTML content model. Need foreign content logic.
+                        // tb.pop(); // Don't pop, wait for end tag or implied close.
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) { // caption, col, colgroup, frame, head, tbody, td, tfoot, th, thead, tr
                         tb.error(this);
-                        return false;
-                    } else {
+                        return false; // Ignore these tags in body
+                    } else { // Any other start tag
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
+                        // Acknowledge self-closing flag for unknown tags? Seems reasonable.
+                         if (startTag.isSelfClosing()) tb.tokeniser.acknowledgeSelfClosingFlag();
                     }
-                    break;
+                    break; // End StartTag
 
                 case EndTag:
                     Token.EndTag endTag = t.asEndTag();
                     name = endTag.normalName();
                     if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {
                         // Adoption Agency Algorithm.
+                         // Loop limit prevents runaway in deeply nested cases.
                          for (int i = 0; i < 8; i++) {
                             Element formatEl = tb.getActiveFormattingElement(name);
-                            if (formatEl == null)
-                                return anyOtherEndTag(t, tb);
-                            else if (!tb.onStack(formatEl)) {
+                            if (formatEl == null) // Element not in AFE list
+                                return anyOtherEndTag(t, tb); // Process as generic end tag
+                            else if (!tb.onStack(formatEl)) { // In AFE list but not on stack
                                 tb.error(this);
                                 tb.removeFromActiveFormattingElements(formatEl);
-                                return true;
-                            } else if (!tb.inScope(formatEl.nodeName())) {
-                                tb.error(this);
-                                return false;
-                            } else if (tb.currentElement() != formatEl)
+                                return true; // Handled (by removing from AFE)
+                            } else if (!tb.inScope(formatEl.nodeName())) { // Not in scope
                                 tb.error(this);
+                                return false; // Ignore token
+                            }
+                            // Element is in AFE, on stack, and in scope. Proceed with AAA.
+                            else if (tb.currentElement() != formatEl) {
+                                // Error if current node isn't the formatting element itself?
+                                // Spec doesn't mandate error *here*. AAA handles mismatches.
+                                // tb.error(this); // Let's omit this specific error check.
+                            }
 
+                            // Find furthest block and common ancestor (node below formatEl)
                             Element furthestBlock = null;
                             Element commonAncestor = null;
+                            // Search downwards from top of stack (index size-1) to find formatEl, then continue down to find furthestBlock.
                             boolean seenFormattingElement = false;
                             ArrayList<Element> stack = tb.getStack();
-                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
-                            // run-aways
                             final int stackSize = stack.size();
-                            for (int si = 0; si < stackSize && si < 64; si++) {
+                            Element formatElPredecessor = null; // Element immediately below formatEl on stack
+                            for (int si = stackSize - 1; si >= 0; si--) { // Iterate stack from top down
                                 Element el = stack.get(si);
                                 if (el == formatEl) {
-                                    commonAncestor = stack.get(si - 1);
+                                    if ((si - 1) >= 0) formatElPredecessor = stack.get(si - 1);
                                     seenFormattingElement = true;
                                 } else if (seenFormattingElement && tb.isSpecial(el)) {
-                                    furthestBlock = el;
+                                    furthestBlock = el; // Found furthest block below formatEl
                                     break;
                                 }
                             }
-                            if (furthestBlock == null) {
+                            commonAncestor = formatElPredecessor; // The node below formatEl is the common ancestor for append later
+
+                            if (furthestBlock == null) { // No block node found below formatEl in stack
+                                // Pop up to and including formatEl, remove from AFE.
                                 tb.popStackToClose(formatEl.nodeName());
                                 tb.removeFromActiveFormattingElements(formatEl);
-                                return true;
+                                return true; // Handled
                             }
 
-                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
-                            // does that mean: int pos of format el in list?
+                            // Check if furthest block is still on stack (paranoia check, should be true)
+                            if (!tb.onStack(furthestBlock)) {
+                                tb.error(this); // Should not happen if stack search is correct
+                                tb.removeFromActiveFormattingElements(formatEl);
+                                return true; // Abort and remove AFE entry
+                            }
+
+                            // Inner loop: Re-parent nodes between furthest block and format element.
                             Element node = furthestBlock;
                             Element lastNode = furthestBlock;
+                            // The loop limit (3) is somewhat arbitrary, check spec basis. It prevents excessive reconstruction.
                             for (int j = 0; j < 3; j++) {
-                                if (tb.onStack(node))
-                                    node = tb.aboveOnStack(node);
-                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
+                                // Node above node in stack (lower index in ArrayList)
+                                int nodeIndex = tb.getStack().indexOf(node);
+                                if (nodeIndex <= 0) break; // Should not happen if formatEl was found above root
+                                Element nextNode = tb.getStack().get(nodeIndex - 1);
+                                node = nextNode; // Move up the stack (down in index)
+
+                                if (!tb.isInActiveFormattingElements(node)) { // If node isn't in AFE, remove from stack and skip
                                     tb.removeFromStack(node);
+                                    // 'node' reference remains pointing to the element *above* the removed one for the next iteration.
                                     continue;
-                                } else if (node == formatEl)
-                                    break;
+                                } else if (node == formatEl) { // Reached the formatting element itself
+                                     break; // Exit inner loop
+                                }
 
-                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());
-                                // case will follow the original node (so honours ParseSettings)
+                                // Replace node with a clone in AFE and stack
+                                Element replacement = new Element(tb.settings.normalizeTag(node.nodeName()), tb.getBaseUri()); // Use settings for case
+                                replacement.attributes().addAll(node.attributes()); // Copy attributes
                                 tb.replaceActiveFormattingElement(node, replacement);
                                 tb.replaceOnStack(node, replacement);
-                                node = replacement;
+                                node = replacement; // Work with the replacement
 
-                                if (lastNode == furthestBlock) {
-                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
-                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
-                                }
+                                // Reparent last node under the new node
                                 if (lastNode.parent() != null)
                                     lastNode.remove();
                                 node.appendChild(lastNode);
 
-                                lastNode = node;
-                            }
+                                lastNode = node; // Update for next iteration
+                            } // End inner loop
 
-                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {
+                            // Insert the reconstructed chain (lastNode)
+                            if (commonAncestor == null) { // Should only happen if formatEl was root or just below? Error condition.
+                                tb.error(this); // Or handle fragment case?
+                                // Fallback: append to current root? Seems wrong. Abort?
+                                // Let's assume commonAncestor is valid based on checks.
+                            }
+                            // Foster parent if common ancestor requires it
+                            else if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {
                                 if (lastNode.parent() != null)
                                     lastNode.remove();
                                 tb.insertInFosterParent(lastNode);
-                            } else {
+                            } else { // Append to common ancestor otherwise
                                 if (lastNode.parent() != null)
                                     lastNode.remove();
                                 commonAncestor.appendChild(lastNode);
                             }
 
+                            // Create adopter element (clone of formatEl)
                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
                             adopter.attributes().addAll(formatEl.attributes());
-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
+
+                            // Move children of furthest block under adopter
+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[0]); // Clone for safe iteration
                             for (Node childNode : childNodes) {
-                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
+                                adopter.appendChild(childNode); // Reparents child
                             }
-                            furthestBlock.appendChild(adopter);
+                            furthestBlock.appendChild(adopter); // Append adopter to furthest block
+
+                            // Cleanup AFE and stack
                             tb.removeFromActiveFormattingElements(formatEl);
-                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
                             tb.removeFromStack(formatEl);
+                            // Insert adopter into stack below furthest block (higher index)
                             tb.insertOnStackAfter(furthestBlock, adopter);
-                        }
+
+                        } // End outer loop (AAA)
+
                     } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {
                         if (!tb.inScope(name)) {
-                            // nothing to close
+                            // nothing to close for this element name in scope
                             tb.error(this);
-                            return false;
+                            return false; // ignore the token
                         } else {
                             tb.generateImpliedEndTags();
                             if (!tb.currentElement().nodeName().equals(name))
-                                tb.error(this);
-                            tb.popStackToClose(name);
+                                tb.error(this); // Current element mismatch after implied tags
+                            tb.popStackToClose(name); // Pop up to and including name
                         }
                     } else if (name.equals("span")) {
-                        // same as final fall through, but saves short circuit
-                        return anyOtherEndTag(t, tb);
+                        // Spec treats span like any other end tag for closing purposes.
+                        return anyOtherEndTag(t, tb); // Delegate to generic end tag handler
                     } else if (name.equals("li")) {
-                        if (!tb.inListItemScope(name)) {
+                        if (!tb.inListItemScope(name)) { // Use list item scope
                             tb.error(this);
-                            return false;
+                            return false; // ignore
                         } else {
-                            tb.generateImpliedEndTags(name);
+                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at <li>
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
-                            tb.popStackToClose(name);
+                            tb.popStackToClose(name); // Close the <li>
                         }
                     } else if (name.equals("body")) {
                         if (!tb.inScope("body")) {
                             tb.error(this);
-                            return false;
+                            return false; // ignore
                         } else {
-                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
+                            // Check stack contents below body for disallowed elements
+                            boolean ok = true;
+                            ArrayList<Element> stack = tb.getStack();
+                             // Iterate from element above body upwards to root
+                             for (int i = stack.indexOf(tb.getStackBodyElement()) - 1; i >=0; i--) { // Find body index, check above it
+                                 if (i < 0) break; // Should find body if inScope passed
+                                 Element el = stack.get(i);
+                                 if (el.nodeName().equals("html")) break; // Stop at html root
+                                 if (!StringUtil.inSorted(el.nodeName(), Constants.InBodyEndBodyStack)) {
+                                      ok = false; break;
+                                  }
+                              }
+                             if (!ok) {
+                                 tb.error(this);
+                                 // Continue processing anyway
+                             }
                              tb.transition(AfterBody);
                          }
                     } else if (name.equals("html")) {
-                        boolean notIgnored = tb.processEndTag("body");
-                        if (notIgnored)
-                            return tb.process(endTag);
+                        // Process as if </body> was seen, then reprocess </html> if </body> wasn't ignored.
+                        boolean bodyProcessed = tb.processEndTag("body"); // Try processing </body>
+                        if (bodyProcessed)
+                            return tb.process(endTag); // Reprocess </html> in the new state (AfterBody)
+                        else
+                            return false; // If </body> was ignored, ignore </html> too.
                     } else if (name.equals("form")) {
+                        if (!tb.isFragmentParsing()) { // Only apply form element logic if not fragment parsing
                             Element currentForm = tb.getFormElement();
-                        tb.setFormElement(null);
+                            tb.setFormElement(null); // Always clear the pointer
+
                             if (currentForm == null || !tb.inScope(name)) {
                                 tb.error(this);
-                            return false;
+                                return false; // Ignore token if no form element context or not in scope
                             } else {
                                 tb.generateImpliedEndTags();
                                 if (!tb.currentElement().nodeName().equals(name))
                                     tb.error(this);
-                            // remove currentForm from stack. will shift anything under up.
-                            tb.removeFromStack(currentForm);
+                                // Remove the specific currentForm element instance from stack.
+                                if (tb.removeFromStack(currentForm)) { // Ensure removal happened
+                                    // If form is removed, need to check if template element needs popping? No, spec for </template> handles that.
+                                } else {
+                                    // Error: currentForm was not on stack? Should not happen if inScope passed.
+                                    tb.error(this);
+                                }
+                            }
+                        } else { // Fragment parsing: treat like any other end tag?
+                             return anyOtherEndTag(t, tb); // Or specific scope check + close? Let's use generic close for fragments.
                          }
                     } else if (name.equals("p")) {
-                        if (!tb.inButtonScope(name)) {
+                        if (!tb.inButtonScope(name)) { // Use button scope
                             tb.error(this);
-                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>
-                            return tb.process(endTag);
+                            tb.processStartTag(name); // Insert an empty <p>
+                            return tb.process(endTag); // Reprocess the </p> tag
                         } else {
-                            tb.generateImpliedEndTags(name);
+                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at <p>
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
-                            tb.popStackToClose(name);
+                            tb.popStackToClose(name); // Close the <p>
                         }
                     } else if (StringUtil.inSorted(name, Constants.DdDt)) {
-                        if (!tb.inScope(name)) {
+                        if (!tb.inScope(name)) { // Use standard scope
                             tb.error(this);
-                            return false;
+                            return false; // ignore
                         } else {
-                            tb.generateImpliedEndTags(name);
+                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at dd/dt
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
-                            tb.popStackToClose(name);
+                            tb.popStackToClose(name); // Close the dd/dt
                         }
                     } else if (StringUtil.inSorted(name, Constants.Headings)) {
-                        if (!tb.inScope(Constants.Headings)) {
+                        if (!tb.inScope(Constants.Headings)) { // Check if *any* heading is in scope
                             tb.error(this);
-                            return false;
+                            return false; // ignore
                         } else {
-                            tb.generateImpliedEndTags(name);
+                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at the specific heading level
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
-                            tb.popStackToClose(Constants.Headings);
+                            tb.popStackToClose(Constants.Headings); // Pop up to and including *any* heading element.
                         }
                     } else if (name.equals("sarcasm")) {
-                        // *sigh*
+                        // Spec doesn't define sarcasm tag. Treat as "any other end tag".
                         return anyOtherEndTag(t, tb);
-                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {
-                        if (!tb.inScope("name")) {
-                            if (!tb.inScope(name)) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) { // End tags: </applet>, </embed>, </object>, </marquee>
+                         // Corrected logic:
+                         if (!tb.inScope(name)) { // Check if the specific tag is in scope
                              tb.error(this);
-                                return false;
-                            }
-                            tb.generateImpliedEndTags();
-                            if (!tb.currentElement().nodeName().equals(name))
-                                tb.error(this);
-                            tb.popStackToClose(name);
-                            tb.clearFormattingElementsToLastMarker();
-                        }
-                    } else if (name.equals("br")) {
-                        tb.error(this);
-                        tb.processStartTag("br");
-                        return false;
+                             return false; // Ignore the token
                          } else {
+                             // Element is in scope
+                             tb.generateImpliedEndTags(); // Generate implied end tags generally
+                             if (!tb.currentElement().nodeName().equals(name)) {
+                                 tb.error(this);
+                             }
+                             tb.popStackToClose(name); // Pop up to and including the element
+                             tb.clearFormattingElementsToLastMarker(); // Clear AFE list back to the last marker
+                         }
+                    } else if (name.equals("br")) { // Specific handler for </br>
+                        tb.error(this);
+                        tb.processStartTag("br"); // Process as <br> start tag
+                        return false; // Ignore the </br> end tag token itself.
+                    } else { // Any other end tag not explicitly handled above
                         return anyOtherEndTag(t, tb);
                     }
 
-                    break;
+                    break; // End EndTag case
                 case EOF:
-                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
-                    // stop parsing
+                    // Check stack for disallowed elements
+                    ArrayList<Element> stack = tb.getStack();
+                     for (int i = stack.size() - 1; i >= 0; i--) { // Iterate from top down
+                         Element el = stack.get(i);
+                         if (el.nodeName().equals("html")) break; // Stop at root (html is allowed)
+                         if (el.nodeName().equals("body")) continue; // body is allowed, check above it
+                         if (el.nodeName().equals("template")) continue; // template is allowed
+                         // Check if element is one of the allowed types at EOF
+                         if (!StringUtil.inSorted(el.nodeName(), Constants.InBodyEndEofStack)) {
+                              tb.error(this);
+                              // Don't break check, report all errors? Spec implies just report error.
+                              // Let's break after first error found.
                               break;
                           }
-            return true;
+                      }
+                    // Stop parsing handled by main loop detecting EOF.
+                    break; // End EOF case
+            } // End switch
+            return true; // Indicate token was handled (unless false returned explicitly)
+        }
+
+        // Helper method to check if string is whitespace (assuming it exists in context or StringUtil)
+        // Added here for completeness if it wasn't implicitly available.
+        private boolean isWhitespace(String data) {
+             return StringUtil.isBlank(data);
         }
\ No newline at end of file
