diff --git a/tmp/32a5f815-35bc-45f8-ad43-215e934e7675_buggy.java b/tmp/c589fcd6-94fd-458d-8ca6-1e5ea1e54be3_fixed.java
index e1fc51f..e629066 100644
--- a/tmp/32a5f815-35bc-45f8-ad43-215e934e7675_buggy.java
+++ b/tmp/c589fcd6-94fd-458d-8ca6-1e5ea1e54be3_fixed.java
@@ -1,9 +1,39 @@
     public boolean hasSameMethod(Invocation candidate) {
         //not using method.equals() for 1 good reason:
         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
 
-        	/* Avoid unnecessary cloning */
-        return m1.equals(m2);
+        /* Avoid unnecessary cloning - This comment seems unrelated/outdated in the original code */
+        // Original faulty code: return m1.equals(m2);
+        // This is too strict because bridge methods generated by the compiler for generics
+        // may not be equal() to the original method definition, even though they represent
+        // the same logical method call from the user's perspective. See failing tests like
+        // InheritedGenericsPolimorphicCallTest.
+
+        // Quick check for identity or exact equality provided by Method.equals()
+        // This handles the simple case and might be a performance optimization.
+        if (m1 == m2 || m1.equals(m2)) {
+            return true;
+        }
+
+        // Perform a looser comparison based on method name and parameter types.
+        // This is generally sufficient to match methods correctly across potential
+        // bridge methods or differences arising from type erasure and inheritance.
+
+        // 1. Compare method names
+        if (!m1.getName().equals(m2.getName())) {
+            return false;
+        }
+
+        // 2. Compare parameter types
+        // java.util.Arrays.equals handles arrays of different lengths, nulls, and primitives correctly.
+        if (!java.util.Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes())) {
+            return false;
+        }
+
+        // If the name and parameter types match, we consider the methods to be logically equivalent
+        // for Mockito's purposes (stubbing, verification matching). This allows matching
+        // invocations made through raw types with stubbings/verifications made using generic types.
+        return true;
     }
\ No newline at end of file
