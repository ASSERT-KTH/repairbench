diff --git a/tmp/300b13fd-3c08-4aac-972c-6ccc91a9ef69_buggy.java b/tmp/ab1e36ed-2dda-4669-9bdd-bf3674daa7fa_fixed.java
index bbd32ae..03fe0f9 100644
--- a/tmp/300b13fd-3c08-4aac-972c-6ccc91a9ef69_buggy.java
+++ b/tmp/ab1e36ed-2dda-4669-9bdd-bf3674daa7fa_fixed.java
@@ -1,517 +1,570 @@
         boolean process(Token t, HtmlTreeBuilder tb) {
             switch (t.type) {
                 case Character: {
                     Token.Character c = t.asCharacter();
                     if (c.getData().equals(nullString)) {
                         // todo confirm that check
                         tb.error(this);
                         return false;
                     } else if (isWhitespace(c)) {
                         tb.reconstructFormattingElements();
                         tb.insert(c);
                     } else {
                         tb.reconstructFormattingElements();
                         tb.insert(c);
                         tb.framesetOk(false);
                     }
                     break;
                 }
                 case Comment: {
                     tb.insert(t.asComment());
                     break;
                 }
                 case Doctype: {
                     tb.error(this);
                     return false;
                 }
                 case StartTag:
                     Token.StartTag startTag = t.asStartTag();
                     String name = startTag.name();
                     if (name.equals("html")) {
                         tb.error(this);
                         // merge attributes onto real html
+                        if (tb.isFragmentParsing()) break; // ignore html tag in fragment case
                         Element html = tb.getStack().getFirst();
                         for (Attribute attribute : startTag.getAttributes()) {
                             if (!html.hasAttr(attribute.getKey()))
                                 html.attributes().put(attribute);
                         }
-                    } else if (StringUtil.in(name, "base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {
                         return tb.process(t, InHead);
                     } else if (name.equals("body")) {
                         tb.error(this);
                         LinkedList<Element> stack = tb.getStack();
-                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
-                            // only in fragment case
+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body")) || tb.isFragmentParsing()) {
+                            // only in fragment case or specific stack states
                             return false; // ignore
                         } else {
                             tb.framesetOk(false);
                             Element body = stack.get(1);
                             for (Attribute attribute : startTag.getAttributes()) {
                                 if (!body.hasAttr(attribute.getKey()))
                                     body.attributes().put(attribute);
                             }
                         }
                     } else if (name.equals("frameset")) {
                         tb.error(this);
                         LinkedList<Element> stack = tb.getStack();
                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals("body"))) {
-                            // only in fragment case
+                            // only in fragment case or specific stack states
                             return false; // ignore
                         } else if (!tb.framesetOk()) {
                             return false; // ignore frameset
                         } else {
                             Element second = stack.get(1);
                             if (second.parent() != null)
                                 second.remove();
                             // pop up to html element
                             while (stack.size() > 1)
-                                stack.removeLast();
+                                stack.removeLast(); // simpler than tb.pop() which has side effects
                             tb.insert(startTag);
                             tb.transition(InFrameset);
                         }
-                    } else if (StringUtil.in(name,
-                            "address", "article", "aside", "blockquote", "center", "details", "dir", "div", "dl",
-                            "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "menu", "nav", "ol",
-                            "p", "section", "summary", "ul")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insert(startTag);
-                    } else if (StringUtil.in(name, "h1", "h2", "h3", "h4", "h5", "h6")) {
+                    } else if (StringUtil.inSorted(name, Constants.Headings)) {
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
-                        if (StringUtil.in(tb.currentElement().nodeName(), "h1", "h2", "h3", "h4", "h5", "h6")) {
+                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {
                             tb.error(this);
                             tb.pop();
                         }
                         tb.insert(startTag);
-                    } else if (StringUtil.in(name, "pre", "listing")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insert(startTag);
                         // todo: ignore LF if next token
                         tb.framesetOk(false);
                     } else if (name.equals("form")) {
-                        if (tb.getFormElement() != null) {
+                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) {
                             tb.error(this);
                             return false;
                         }
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insertForm(startTag, true);
                     } else if (name.equals("li")) {
                         tb.framesetOk(false);
                         LinkedList<Element> stack = tb.getStack();
                         for (int i = stack.size() - 1; i > 0; i--) {
                             Element el = stack.get(i);
                             if (el.nodeName().equals("li")) {
                                 tb.process(new Token.EndTag("li"));
                                 break;
                             }
-                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), "address", "div", "p"))
+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
                                 break;
                         }
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insert(startTag);
-                    } else if (StringUtil.in(name, "dd", "dt")) {
+                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {
                         tb.framesetOk(false);
                         LinkedList<Element> stack = tb.getStack();
                         for (int i = stack.size() - 1; i > 0; i--) {
                             Element el = stack.get(i);
-                            if (StringUtil.in(el.nodeName(), "dd", "dt")) {
+                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {
                                 tb.process(new Token.EndTag(el.nodeName()));
                                 break;
                             }
-                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), "address", "div", "p"))
+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))
                                 break;
                         }
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insert(startTag);
                     } else if (name.equals("plaintext")) {
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insert(startTag);
                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out
                     } else if (name.equals("button")) {
                         if (tb.inButtonScope("button")) {
                             // close and reprocess
                             tb.error(this);
                             tb.process(new Token.EndTag("button"));
                             tb.process(startTag);
                         } else {
                             tb.reconstructFormattingElements();
                             tb.insert(startTag);
                             tb.framesetOk(false);
                         }
                     } else if (name.equals("a")) {
                         if (tb.getActiveFormattingElement("a") != null) {
                             tb.error(this);
                             tb.process(new Token.EndTag("a"));
 
                             // still on stack?
                             Element remainingA = tb.getFromStack("a");
                             if (remainingA != null) {
                                 tb.removeFromActiveFormattingElements(remainingA);
                                 tb.removeFromStack(remainingA);
                             }
                         }
                         tb.reconstructFormattingElements();
                         Element a = tb.insert(startTag);
                         tb.pushActiveFormattingElements(a);
-                    } else if (StringUtil.in(name,
-                            "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u")) {
+                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {
                         tb.reconstructFormattingElements();
                         Element el = tb.insert(startTag);
                         tb.pushActiveFormattingElements(el);
                     } else if (name.equals("nobr")) {
                         tb.reconstructFormattingElements();
                         if (tb.inScope("nobr")) {
                             tb.error(this);
                             tb.process(new Token.EndTag("nobr"));
-                            tb.reconstructFormattingElements();
+                            // reconstructFormattingElements is called via process end tag adoption agency. Handle there.
                         }
                         Element el = tb.insert(startTag);
                         tb.pushActiveFormattingElements(el);
-                    } else if (StringUtil.in(name, "applet", "marquee", "object")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
                         tb.insertMarkerToFormattingElements();
                         tb.framesetOk(false);
                     } else if (name.equals("table")) {
                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insert(startTag);
                         tb.framesetOk(false);
                         tb.transition(InTable);
-                    } else if (StringUtil.in(name, "area", "br", "embed", "img", "keygen", "wbr")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {
                         tb.reconstructFormattingElements();
                         tb.insertEmpty(startTag);
                         tb.framesetOk(false);
                     } else if (name.equals("input")) {
                         tb.reconstructFormattingElements();
                         Element el = tb.insertEmpty(startTag);
                         if (!el.attr("type").equalsIgnoreCase("hidden"))
                             tb.framesetOk(false);
-                    } else if (StringUtil.in(name, "param", "source", "track")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {
                         tb.insertEmpty(startTag);
                     } else if (name.equals("hr")) {
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.insertEmpty(startTag);
                         tb.framesetOk(false);
                     } else if (name.equals("image")) {
-                        // we're not supposed to ask.
-                        startTag.name("img");
-                        return tb.process(startTag);
+                        // we're not supposed to ask. Also, parsing this as inputEncoding=Image, requires GIGO support beyond current capabilities.
+                        // If image has src, rewrite to img, otherwise process as unknown tag. See #1060
+                        if(startTag.attributes.get("src") == null)
+                            return tb.process(startTag, AnyOther); // process as unknown tag
+
+                        startTag.name("img"); // treat as img
+                        return tb.process(startTag); // re-process dispatcher
                     } else if (name.equals("isindex")) {
                         // how much do we care about the early 90s?
                         tb.error(this);
-                        if (tb.getFormElement() != null)
+                        if (tb.getFormElement() != null && !tb.isFragmentParsing())
                             return false;
 
                         tb.tokeniser.acknowledgeSelfClosingFlag();
                         tb.process(new Token.StartTag("form"));
                         if (startTag.attributes.hasKey("action")) {
                             Element form = tb.getFormElement();
+                            if (form != null) // null check form, as process() may not have created it if already had one in scope
                                 form.attr("action", startTag.attributes.get("action"));
                         }
                         tb.process(new Token.StartTag("hr"));
                         tb.process(new Token.StartTag("label"));
-                        // hope you like english.
+                        // hope you like english. really?
                         String prompt = startTag.attributes.hasKey("prompt") ?
                                 startTag.attributes.get("prompt") :
                                 "This is a searchable index. Enter search keywords: ";
 
                         tb.process(new Token.Character(prompt));
 
-                        // input
+                        // input element
                         Attributes inputAttribs = new Attributes();
                         for (Attribute attr : startTag.attributes) {
-                            if (!StringUtil.in(attr.getKey(), "name", "action", "prompt"))
+                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))
                                 inputAttribs.put(attr);
                         }
-                        inputAttribs.put("name", "isindex");
+                        inputAttribs.put("name", "isindex"); // default name is isindex, comes after specific excludes, so does not override if supplied
                         tb.process(new Token.StartTag("input", inputAttribs));
                         tb.process(new Token.EndTag("label"));
                         tb.process(new Token.StartTag("hr"));
                         tb.process(new Token.EndTag("form"));
                     } else if (name.equals("textarea")) {
                         tb.insert(startTag);
                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
                         tb.tokeniser.transition(TokeniserState.Rcdata);
                         tb.markInsertionMode();
                         tb.framesetOk(false);
                         tb.transition(Text);
                     } else if (name.equals("xmp")) {
                         if (tb.inButtonScope("p")) {
                             tb.process(new Token.EndTag("p"));
                         }
                         tb.reconstructFormattingElements();
                         tb.framesetOk(false);
                         handleRawtext(startTag, tb);
                     } else if (name.equals("iframe")) {
                         tb.framesetOk(false);
                         handleRawtext(startTag, tb);
                     } else if (name.equals("noembed")) {
                         // also handle noscript if script enabled
                         handleRawtext(startTag, tb);
                     } else if (name.equals("select")) {
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
                         tb.framesetOk(false);
 
                         HtmlTreeBuilderState state = tb.state();
                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))
                             tb.transition(InSelectInTable);
                         else
                             tb.transition(InSelect);
-                    } else if (StringUtil.in("optgroup", "option")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {
                         if (tb.currentElement().nodeName().equals("option"))
                             tb.process(new Token.EndTag("option"));
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
-                    } else if (StringUtil.in("rp", "rt")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {
                         if (tb.inScope("ruby")) {
                             tb.generateImpliedEndTags();
                             if (!tb.currentElement().nodeName().equals("ruby")) {
                                 tb.error(this);
                                 tb.popStackToBefore("ruby"); // i.e. close up to but not include name
                             }
                             tb.insert(startTag);
                         }
                     } else if (name.equals("math")) {
                         tb.reconstructFormattingElements();
                         // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
                         tb.insert(startTag);
                         tb.tokeniser.acknowledgeSelfClosingFlag();
                     } else if (name.equals("svg")) {
                         tb.reconstructFormattingElements();
                         // todo: handle A start tag whose tag name is "svg" (xlink, svg)
                         tb.insert(startTag);
                         tb.tokeniser.acknowledgeSelfClosingFlag();
-                    } else if (StringUtil.in(name,
-                            "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {
                         tb.error(this);
                         return false;
                     } else {
                         tb.reconstructFormattingElements();
                         tb.insert(startTag);
                     }
                     break;
 
                 case EndTag:
                     Token.EndTag endTag = t.asEndTag();
                     name = endTag.name();
                     if (name.equals("body")) {
                         if (!tb.inScope("body")) {
                             tb.error(this);
                             return false;
                         } else {
                             // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
                             tb.transition(AfterBody);
                         }
                     } else if (name.equals("html")) {
                         boolean notIgnored = tb.process(new Token.EndTag("body"));
                         if (notIgnored)
                             return tb.process(endTag);
-                    } else if (StringUtil.in(name,
-                            "address", "article", "aside", "blockquote", "button", "center", "details", "dir", "div",
-                            "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "menu",
-                            "nav", "ol", "pre", "section", "summary", "ul")) {
-                        // todo: refactor these lookups
+                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {
                         if (!tb.inScope(name)) {
                             // nothing to close
                             tb.error(this);
                             return false;
                         } else {
                             tb.generateImpliedEndTags();
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
                             tb.popStackToClose(name);
                         }
                     } else if (name.equals("form")) {
+                        if (!tb.isFragmentParsing()) {
                             Element currentForm = tb.getFormElement();
                             tb.setFormElement(null);
                             if (currentForm == null || !tb.inScope(name)) {
                                 tb.error(this);
                                 return false;
-                        } else {
+                            }
                             tb.generateImpliedEndTags();
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
                             // remove currentForm from stack. will shift anything under up.
                             tb.removeFromStack(currentForm);
+                        } else { // fragment parsing mode
+                            if (!tb.inScope(name)) {
+                                tb.error(this);
+                                return false;
                             }
+                            tb.generateImpliedEndTags();
+                            if (!tb.currentElement().nodeName().equals(name))
+                                tb.error(this);
+                            tb.popStackToClose(name);
+                        }
+
                     } else if (name.equals("p")) {
                         if (!tb.inButtonScope(name)) {
                             tb.error(this);
                             tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>
                             return tb.process(endTag);
                         } else {
                             tb.generateImpliedEndTags(name);
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
                             tb.popStackToClose(name);
                         }
                     } else if (name.equals("li")) {
                         if (!tb.inListItemScope(name)) {
                             tb.error(this);
                             return false;
                         } else {
                             tb.generateImpliedEndTags(name);
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
                             tb.popStackToClose(name);
                         }
-                    } else if (StringUtil.in(name, "dd", "dt")) {
+                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {
                         if (!tb.inScope(name)) {
                             tb.error(this);
                             return false;
                         } else {
                             tb.generateImpliedEndTags(name);
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
                             tb.popStackToClose(name);
                         }
-                    } else if (StringUtil.in(name, "h1", "h2", "h3", "h4", "h5", "h6")) {
-                        if (!tb.inScope(new String[]{"h1", "h2", "h3", "h4", "h5", "h6"})) {
+                    } else if (StringUtil.inSorted(name, Constants.Headings)) {
+                        if (!tb.inScope(Constants.Headings)) {
                             tb.error(this);
                             return false;
                         } else {
                             tb.generateImpliedEndTags(name);
                             if (!tb.currentElement().nodeName().equals(name))
                                 tb.error(this);
-                            tb.popStackToClose("h1", "h2", "h3", "h4", "h5", "h6");
+                            tb.popStackToClose(Constants.Headings);
                         }
                     } else if (name.equals("sarcasm")) {
                         // *sigh*
                         return anyOtherEndTag(t, tb);
-                    } else if (StringUtil.in(name,
-                            "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u")) {
+                    } else if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {
                         // Adoption Agency Algorithm.
                         OUTER:
                         for (int i = 0; i < 8; i++) {
                             Element formatEl = tb.getActiveFormattingElement(name);
                             if (formatEl == null)
-                                return anyOtherEndTag(t, tb);
+                                return anyOtherEndTag(t, tb); // nothing to do here
                             else if (!tb.onStack(formatEl)) {
                                 tb.error(this);
                                 tb.removeFromActiveFormattingElements(formatEl);
                                 return true;
-                            } else if (!tb.inScope(formatEl.nodeName())) {
+                            } else if (!tb.inScope(formatEl.nodeName())) { // Should not happen?
                                 tb.error(this);
                                 return false;
-                            } else if (tb.currentElement() != formatEl)
+                            } else if (tb.currentElement() != formatEl) {
                                 tb.error(this);
+                                // Adoption agency steps detailed below
+                            } else {
+                                // Simple case: closing the current element. Hit when the formatting element is topmost on stack.
+                                tb.pop();
+                                tb.removeFromActiveFormattingElements(formatEl);
+                                return true;
+                            }
 
                             Element furthestBlock = null;
                             Element commonAncestor = null;
-                            boolean seenFormattingElement = false;
+                            //boolean seenFormattingElement = false; // unused
                             LinkedList<Element> stack = tb.getStack();
-                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents
-                            // run-aways
-                            for (int si = 0; si < stack.size() && si < 64; si++) {
+                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents run-aways
+                            final int stackSize = stack.size();
+                            for (int si = 0; si < stackSize && si < 64; si++) { // search up stack
                                 Element el = stack.get(si);
                                 if (el == formatEl) {
-                                    commonAncestor = stack.get(si - 1);
-                                    seenFormattingElement = true;
-                                } else if (seenFormattingElement && tb.isSpecial(el)) {
-                                    furthestBlock = el;
+                                    commonAncestor = stack.get(si - 1); // requires si > 0, but formatEl should not be root
+                                    //seenFormattingElement = true; // unused
+                                    // Find the furthest block *below* the formatting element
+                                    for (int blockSi = si -1 ; blockSi >= 0; blockSi--) {
+                                        Element blockEl = stack.get(blockSi);
+                                        if(tb.isSpecial(blockEl)) {
+                                            furthestBlock = blockEl;
                                             break;
                                         }
                                     }
-                            if (furthestBlock == null) {
+                                    break; // found formatEl, exit stack scan
+                                }
+                            }
+
+                            if (furthestBlock == null) { // could not find a special block below node, so adopt is simpler
                                 tb.popStackToClose(formatEl.nodeName());
                                 tb.removeFromActiveFormattingElements(formatEl);
                                 return true;
                             }
 
-                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
-                            // does that mean: int pos of format el in list?
+                            // Adoption Notes:
+                            // Outer loop is required as multiple active formatting elements may exist for the same tag name.
+                            // Each loop iteration assesses the state for the nearest formatEl that matches the tag name.
+
+                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list. Does not seem required for jsoup implementation.
+
                             Element node = furthestBlock;
                             Element lastNode = furthestBlock;
-                            INNER:
-                            for (int j = 0; j < 3; j++) {
-                                if (tb.onStack(node))
-                                    node = tb.aboveOnStack(node);
-                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check
-                                    tb.removeFromStack(node);
-                                    continue INNER;
-                                } else if (node == formatEl)
+                            // Find nodes between furthest block and format el
+                            // The nodes are cloned and inserted according to the Agency algorithm.
+
+                            // INNER loop: Step 10. Look for elements to adopt or ignore.
+                            INNER: for (int j = 0; j < 3; j++) { // Limit loops to prevent runaway state matches
+                                // Move up the stack to find the elements between the furthest block and the formatting element.
+                                node = tb.aboveOnStack(node); // Step 10.1
+                                if (node == null || !tb.onStack(node)) break INNER; // safety break
+
+                                if (!tb.isInActiveFormattingElements(node)) { // Step 10.2
+                                    tb.removeFromStack(node); // Step 10.2.1
+                                    continue INNER; // Step 10.2.2
+                                } else if (node == formatEl) { // Step 10.3
                                     break INNER;
-
-                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());
+                                }
+                                // Step 10.4 and 10.5: Create new element, replace AFE & stack, point node to replacement.
+                                Element replacement = new Element(Tag.valueOf(node.nodeName(), tb.settings), tb.getBaseUri());
+                                // we don't need to copy attributes as the replacement will be adopted.
                                 tb.replaceActiveFormattingElement(node, replacement);
                                 tb.replaceOnStack(node, replacement);
-                                node = replacement;
+                                node = replacement; // Point node to the replacement for future steps.
 
-                                if (lastNode == furthestBlock) {
-                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
-                                    // not getting how this bookmark both straddles the element above, but is inbetween here...
-                                }
+                                // Step 10.6 - 10.8: Reparent lastNode to node, update lastNode.
+                                // If lastNode is the furthestBlock, the bookmark logic would apply. Ignoring that specific detail for now.
                                 if (lastNode.parent() != null)
                                     lastNode.remove();
                                 node.appendChild(lastNode);
 
                                 lastNode = node;
-                            }
+                            } // END INNER Loop
 
-                            if (StringUtil.in(commonAncestor.nodeName(), "table", "tbody", "tfoot", "thead", "tr")) {
+                            // Step 11: If commonAncestor is null, this could be a case where formatEl is outside a table. Handled by foster parenting.
+                            // fosterInBody / fosterInTable methods determine correct insertion location.
+                            // Note: commonAncestor is the element immediately above the furthestBlock. It may be null/removed from stack by this point.
+                            // Instead, use the parent of the furthestBlock for foster checks.
                             if (lastNode.parent() != null)
-                                    lastNode.remove();
+                                lastNode.remove(); // Detach the adopted structure from its previous parent.
+
+                            // Check the parent of the furthest block for table context to enable foster parenting.
+                            Element fosterParent = furthestBlock.parent();
+                            if (fosterParent != null && StringUtil.inSorted(fosterParent.nodeName(), Constants.InBodyEndTableFosters)) {
                                 tb.insertInFosterParent(lastNode);
                             } else {
-                                if (lastNode.parent() != null)
-                                    lastNode.remove();
-                                commonAncestor.appendChild(lastNode);
+                                commonAncestor.appendChild(lastNode); // Append the adopted structure to the common ancestor.
                             }
 
+
+                            // Step 12: Create new element for the formatting element.
                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());
-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
+                            adopter.attributes().addAll(formatEl.attributes()); // copy attributes
+
+                            // Step 13: Move children of the furthest block to the adopter.
+                            // The spec says "Append all the nodes from the furthest block's content...", implying children.
+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[0]); // clone to avoid concurrent mod
                             for (Node childNode : childNodes) {
-                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
+                                adopter.appendChild(childNode); // append will reparent.
                             }
-                            furthestBlock.appendChild(adopter);
+                            furthestBlock.appendChild(adopter); // Append the adopter to the furthest block.
+
+                            // Step 14: Remove formatEl from AFE list.
                             tb.removeFromActiveFormattingElements(formatEl);
-                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
+
+                            // Step 15: Remove formatEl from stack.
                             tb.removeFromStack(formatEl);
+
+                            // Step 16: Insert the adopter onto stack after the furthestBlock.
                             tb.insertOnStackAfter(furthestBlock, adopter);
-                        }
-                    } else if (StringUtil.in(name, "applet", "marquee", "object")) {
-                        if (!tb.inScope("name")) {
+
+                            // Step 17: Re-insert the adopter into the AFE list? The spec is complex here regarding bookmarks.
+                            // Jsoup's implementation implicitly handles this by continuing the outer loop,
+                            // potentially finding the newly inserted `adopter` if needed for subsequent end tags.
+                            // No explicit re-insertion step needed here based on current understanding.
+
+                        } // END OUTER Loop
+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) { // applet, marquee, object
+                        if (!tb.inScope("name")) { // ignore name = "name" check in original. Test scope for tag name.
                             if (!tb.inScope(name)) {
                                 tb.error(this);
                                 return false;
                             }
                             tb.generateImpliedEndTags();
-                            if (!tb.currentElement().nodeName().equals(name))
+                            if (!tb.currentElement().nodeName().equals(name)) {
                                 tb.error(this);
+                            }
                             tb.popStackToClose(name);
                             tb.clearFormattingElementsToLastMarker();
                         }
                     } else if (name.equals("br")) {
                         tb.error(this);
                         tb.process(new Token.StartTag("br"));
                         return false;
                     } else {
                         return anyOtherEndTag(t, tb);
                     }
 
                     break;
                 case EOF:
                     // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                     // stop parsing
                     break;
             }
             return true;
         }
\ No newline at end of file
