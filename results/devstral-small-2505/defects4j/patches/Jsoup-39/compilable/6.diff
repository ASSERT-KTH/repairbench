diff --git a/tmp/c26e396c-cdaa-4e09-971d-99327666f2ec_buggy.java b/tmp/b686590b-aa22-421f-9ed4-2ad08e771470_fixed.java
index c4b260c..4795e81 100644
--- a/tmp/c26e396c-cdaa-4e09-971d-99327666f2ec_buggy.java
+++ b/tmp/b686590b-aa22-421f-9ed4-2ad08e771470_fixed.java
@@ -1,51 +1,57 @@
-    // todo - this is getting gnarly. needs a rewrite.
 static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
     String docData;
     Document doc = null;
-        if (charsetName == null) { // determine from meta. safe parse as UTF-8
-            // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">
+
+    // Handle the case where charsetName is null
+    if (charsetName == null) {
+        // Default to UTF-8 and attempt to detect charset from meta tag
         docData = Charset.forName(defaultCharset).decode(byteData).toString();
         doc = parser.parseInput(docData, baseUri);
         Element meta = doc.select("meta[http-equiv=content-type], meta[charset]").first();
-            if (meta != null) { // if not found, will keep utf-8 as best attempt
+        if (meta != null) {
             String foundCharset;
             if (meta.hasAttr("http-equiv")) {
                 foundCharset = getCharsetFromContentType(meta.attr("content"));
                 if (foundCharset == null && meta.hasAttr("charset")) {
                     try {
                         if (Charset.isSupported(meta.attr("charset"))) {
                             foundCharset = meta.attr("charset");
                         }
                     } catch (IllegalCharsetNameException e) {
                         foundCharset = null;
                     }
                 }
             } else {
                 foundCharset = meta.attr("charset");
             }
 
-                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
+            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {
                 foundCharset = foundCharset.trim().replaceAll("[\"']", "");
                 charsetName = foundCharset;
                 byteData.rewind();
                 docData = Charset.forName(foundCharset).decode(byteData).toString();
                 doc = null;
             }
         }
-        } else { // specified by content type header (or by user on file load)
+    } else {
+        // Charset is explicitly provided (either by content type header or user)
         Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
         docData = Charset.forName(charsetName).decode(byteData).toString();
     }
-        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly
+
+    // Handle UTF-8 BOM indicator
     if (docData.length() > 0 && docData.charAt(0) == 65279) {
         byteData.rewind();
         docData = Charset.forName(defaultCharset).decode(byteData).toString();
         docData = docData.substring(1);
         charsetName = defaultCharset;
     }
+
+    // Parse the document if it hasn't been parsed yet
     if (doc == null) {
         doc = parser.parseInput(docData, baseUri);
         doc.outputSettings().charset(charsetName);
     }
+
     return doc;
 }
\ No newline at end of file
