diff --git a/tmp/66515547-998c-42b5-b3d3-a7a0979e3aa3_buggy.java b/tmp/05d8ae8f-9519-4ada-8ca0-35c37dd531aa_fixed.java
index 875b31b..fd8495e 100644
--- a/tmp/66515547-998c-42b5-b3d3-a7a0979e3aa3_buggy.java
+++ b/tmp/05d8ae8f-9519-4ada-8ca0-35c37dd531aa_fixed.java
@@ -1,54 +1,73 @@
     /**
      * Render the specified text and return the rendered Options
      * in a StringBuffer.
      *
      * @param sb The StringBuffer to place the rendered text into.
-     * @param width The number of characters to display per line
-     * @param nextLineTabStop The position on the next line for the first tab.
+     * @param width The number of characters to display per line (this is the content width, not total line width).
+     * @param nextLineTabStop The position on the next line for the first tab (this is the indent length).
      * @param text The text to be rendered.
      *
      * @return the StringBuffer with the rendered Options contents.
      */
     protected StringBuffer renderWrappedText(StringBuffer sb, int width,
                                              int nextLineTabStop, String text)
     {
+        // Create the padding string that will be prepended to all lines generated by this function.
+        // nextLineTabStop is interpreted as the length of this padding.
+        String linePadding = createPadding(nextLineTabStop);
+
+        // Find the wrap position for the *initial* text.
+        // 'text' here is the original input string, so 'width' (content width) applies directly.
         int pos = findWrapPos(text, width, 0);
 
-        if (pos == -1)
+        if (pos == -1) // If the entire text fits on one line (considering the content width)
         {
-            sb.append(rtrim(text));
-
+            // Append the line padding and the trimmed text.
+            sb.append(linePadding).append(rtrim(text));
             return sb;
         }
-        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
 
+        // Append the first wrapped line: padding + content + newline.
+        sb.append(linePadding).append(rtrim(text.substring(0, pos))).append(defaultNewLine);
+
+        // Adjust nextLineTabStop for subsequent lines if it makes the content width effectively zero or negative.
+        // If nextLineTabStop is adjusted, the linePadding needs to be re-created to reflect the change.
         if (nextLineTabStop >= width)
         {
-            // stops infinite loop happening
+            // Ensure there is at least one character space after padding for content.
             nextLineTabStop = width - 1;
+            // Re-create padding as nextLineTabStop might have been adjusted.
+            linePadding = createPadding(nextLineTabStop);
         }
 
-        // all following lines must be padded with nextLineTabStop space 
-        // characters
-        final String padding = createPadding(nextLineTabStop);
-
         while (true)
         {
-            text = padding + text.substring(pos).trim();
-            pos = findWrapPos(text, width, 0);
+            // For subsequent lines, the 'text' is composed of the padding and the remaining content.
+            // trim() removes leading/trailing whitespace from the substring which might occur if findWrapPos broke at a space.
+            text = linePadding + text.substring(pos).trim();
 
-            if (pos == -1)
+            // Now, findWrapPos must operate on this 'padded text'.
+            // The effective total width for this padded text is 'width + nextLineTabStop'.
+            // 'width' is the content width, and 'nextLineTabStop' is the padding length.
+            pos = findWrapPos(text, width + nextLineTabStop, 0);
+
+            if (pos == -1) // Remaining text fits on current padded line
             {
-                sb.append(text);
-
+                sb.append(text); // 'text' already has padding
                 return sb;
             }
 
-            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) 
+            // Special handling: if findWrapPos returns a position within the padding (or just before content starts),
+            // and the overall line is too long, force the break at the 'total width' boundary.
+            // This prevents lines that are essentially just padding or wrap too early, losing content space.
+            // 'pos == nextLineTabStop - 1' means findWrapPos found a break right at the end of the padding.
+            // 'text.length() > width + nextLineTabStop' means the line content, even with padding, is too long.
+            if ( (text.length() > width + nextLineTabStop) && (pos == nextLineTabStop - 1) )
             {
-                pos = width;
+                pos = width + nextLineTabStop; // Force break at the total line width.
             }
 
+            // Append the current wrapped line.
             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);
         }
     }
\ No newline at end of file
